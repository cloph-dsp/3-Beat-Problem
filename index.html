<html><head><base href="https://3beatproblem.websim.io/"><title>3 Beat Problem</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&amp;family=Roboto:wght@300;400;700&amp;display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-color: #0a1019;
      --primary-color: #00fff0; /* Slightly adjusted cyan */
      --secondary-color: #ff34b3; /* Softer magenta */
      --tertiary-color: #ffd700; /* More golden yellow */
      --text-color: #ffffff;
      --control-bg: rgba(255, 255, 255, 0.12);
      --slider-bg: rgba(255, 255, 255, 0.25);
      --select-bg: #1a1f2e;
      --success-color: #4CAF50;
      --error-color: #f44336;
    }
  
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
  
    body {
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(135deg, #0a0e17 0%, #1a1e2e 100%);
      color: var(--text-color);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      overflow-x: hidden;
    }
  
    .container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      background: rgba(255, 255, 255, 0.07);
      padding: 20px;
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0, 255, 255, 0.15);
      backdrop-filter: blur(15px);
      max-width: 1200px;
      width: 95%;
      margin: 20px auto;
    }
  
    .header {
      grid-column: 1 / -1;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 30px;
      margin: -30px -30px 30px -30px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 20px 20px 0 0;
    }
  
    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: var(--primary-color);
      text-shadow: 0 0 10px var(--primary-color);
    }
  
    .bpm-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }
  
    .bpm-control label {
      margin-right: 10px;
      font-size: 14px;
      font-family: 'Orbitron', sans-serif;
    }
  
    #playPause {
      min-width: unset;
      width: 40px;
      height: 40px;
      padding: 0;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--primary-color);
      font-size: 20px;
    }
  
    #playPause:hover {
      transform: scale(1.1);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
    }
  
    .play-icon, .pause-icon {
      display: none;
    }
  
    .play-icon.show, .pause-icon.show {
      display: block;
    }
  
    .export-button {
      background: var(--tertiary-color);
      color: var(--bg-color);
      border: none;
      padding: 8px 15px;
      border-radius: 20px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
      transition: all 0.3s ease;
      margin-left: 10px;
    }
  
    .export-button:hover {
      background: var(--primary-color);
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
    }
  
    .sequencer {
      min-width: 280px;
      height: auto;
      aspect-ratio: 1;
      padding: 25px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      gap: 20px;
    }
  
    .circle-container {
      width: 180px;
      height: 180px;
      margin: 0 auto;
    }
  
    .circle {
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 50%;
      position: relative;
      transition: all 0.3s ease;
      background: radial-gradient(
        circle at center,
        rgba(0,0,0,0.95) 0%,
        rgba(10,16,25,0.9) 40%,
        rgba(26,31,46,0.85) 80%,
        rgba(0,255,240,0.15) 100%
      );
      backdrop-filter: blur(10px);
      box-shadow: 
        0 0 40px rgba(0,255,240,0.15),
        inset 0 0 30px rgba(255,52,179,0.1);
      animation: pulseMain 6s ease-in-out infinite;
    }
  
    .circle::before {
      content: '';
      position: absolute;
      inset: -3px;
      background: conic-gradient(
        from 45deg,
        rgba(0,255,240,0.8),
        rgba(255,52,179,0.8),
        rgba(255,215,0,0.8),
        rgba(0,255,240,0.8)
      );
      border-radius: 50%;
      -webkit-mask: 
        linear-gradient(#fff 0 0) content-box, 
        linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask: 
        linear-gradient(#fff 0 0) content-box, 
        linear-gradient(#fff 0 0);
      mask-composite: exclude;
      padding: 3px;
      animation: spinGradient 12s linear infinite;
      opacity: 0.8;
    }
  
    .circle-inner-ring,
    .circle-middle-ring,
    .circle-outer-ring {
      position: absolute;
      border-radius: 50%;
      border: 2px solid transparent;
      transform-origin: center;
    }
  
    .circle-inner-ring {
      inset: 20%;
      border-image: linear-gradient(45deg, rgba(0,255,240,0.7), transparent) 1;
      animation: spinCounterClockwise 15s linear infinite;
    }
  
    .circle-middle-ring {
      inset: 35%;
      border-image: linear-gradient(135deg, rgba(255,52,179,0.7), transparent) 1;
      animation: spin 10s linear infinite;
    }
  
    .circle-outer-ring {
      inset: 50%;
      border-image: linear-gradient(225deg, rgba(255,215,0,0.7), transparent) 1;
      animation: spinCounterClockwise 20s linear infinite;
    }
  
    .dot {
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, 
        rgba(255,52,179,0.9), 
        rgba(255,105,180,0.9)
      );
      border-radius: 50%;
      position: absolute;
      transform: translate(-50%, -50%);
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 
        0 0 15px rgba(255,52,179,0.4),
        inset 0 0 8px rgba(255,255,255,0.8);
      z-index: 2; /* Ensure dots stay above the visualizer */
    }
  
    .dot::before {
      content: '';
      position: absolute;
      inset: -3px;
      background: conic-gradient(
        from 45deg,
        rgba(0,255,240,0.9),
        rgba(255,52,179,0.9),
        rgba(0,255,240,0.9)
      );
      border-radius: inherit;
      animation: spinGradient 6s linear infinite;
      opacity: 0;
      transition: opacity 0.4s ease;
    }
  
    .dot:hover::before {
      opacity: 1;
    }
  
    .dot:hover {
      transform: translate(-50%, -50%) scale(1.2);
      box-shadow: 
        0 0 25px rgba(255,52,179,0.6),
        inset 0 0 12px rgba(255,255,255,0.9);
    }
  
    .dot.active {
      background: linear-gradient(135deg, 
        rgba(0,255,240,0.95), 
        rgba(0,255,204,0.95)
      );
      box-shadow: 
        0 0 35px rgba(0,255,240,0.6),
        0 0 50px rgba(0,255,240,0.4),
        inset 0 0 20px rgba(255,255,255,0.9);
      animation: activePulse 2s ease-in-out infinite;
    }
  
    .spectrogram {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      width: 100%;  /* This ensures it fits within the circle container */
      height: 100%;
      pointer-events: none;
      z-index: 1;  /* Place it behind other elements */
    }
  
    .volume-control {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
  
    .volume-control label {
      min-width: 60px;
      font-size: 12px;
    }
  
    .volume-control input[type="range"] {
      width: 100px;
      height: 4px;
    }
  
    @keyframes pulseMain {
      0%, 100% {
        box-shadow: 
          0 0 40px rgba(0,255,240,0.15),
          inset 0 0 30px rgba(255,52,179,0.1);
        filter: brightness(1);
      }
      50% {
        box-shadow: 
          0 0 60px rgba(0,255,240,0.25),
          inset 0 0 45px rgba(255,52,179,0.2);
        filter: brightness(1.3);
      }
    }
  
    @keyframes spinGradient {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  
    @keyframes spinCounterClockwise {
      0% { transform: rotate(360deg); }
      100% { transform: rotate(0deg); }
    }
  
    @keyframes activePulse {
      0%, 100% {
        transform: translate(-50%, -50%) scale(1);
        box-shadow: 
          0 0 35px rgba(0,255,240,0.6),
          0 0 50px rgba(0,255,240,0.4),
          inset 0 0 20px rgba(255,255,255,0.9);
      }
      50% {
        transform: translate(-50%, -50%) scale(1.3);
        box-shadow: 
          0 0 45px rgba(0,255,240,0.8),
          0 0 60px rgba(0,255,240,0.6),
          inset 0 0 25px rgba(255,255,255,1);
      }
    }
  
    .orbiting-circle {
      width: 8px;
      height: 8px;
      position: absolute;
      left: 50%;  /* Center point */
      top: 50%;   /* Center point */
      transform-origin: 0 0; /* Set transform origin to top-left */
      border-radius: 50%;
      background: radial-gradient(
        circle at center,
        rgba(0,255,240,0.8),
        rgba(255,52,179,0.8)
      );
      opacity: 0.7;
      transition: all 0.4s ease;
      filter: blur(1px);
      box-shadow: 0 0 15px currentColor;
    }
  
    .controls {
      width: 100%;
      display: grid;
      grid-template-columns: 1fr;
      gap: 15px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 15px;
    }
  
    label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--tertiary-color);
      font-family: 'Orbitron', sans-serif;
    }
  
    select, input[type="number"] {
      background-color: var(--select-bg);
      color: var(--text-color);
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      transition: all 0.3s ease;
    }
  
    select:hover, input[type="number"]:hover {
      border-color: var(--primary-color);
    }
  
    .slider-container {
      grid-column: 1 / -1;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 15px;
      margin-top: 10px;
    }
  
    .slider-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }
  
    input[type="range"] {
      width: 150px;
      height: 6px;
      background: linear-gradient(90deg, var(--primary-color) 0%, var(--secondary-color) 100%);
      border-radius: 3px;
    }
  
    input[type="range"]::-webkit-slider-thumb {
      width: 16px;
      height: 16px;
      background: var(--tertiary-color);
      border: 2px solid var(--primary-color);
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
      -webkit-appearance: none;
    }
  
    .notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 15px 25px;
      border-radius: 8px;
      color: white;
      font-weight: 500;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.3s ease;
    }
  
    .notification.show {
      opacity: 1;
      transform: translateY(0);
    }
  
    .notification.success {
      background-color: var(--success-color);
    }
  
    .notification.error {
      background-color: var(--error-color);
    }
  
    @media (max-width: 1200px) {
      .container {
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        padding: 20px;
      }
      
      .circle-container {
        width: 150px;
        height: 150px;
      }
    }
  
    @media (max-width: 768px) {
      .slider-container {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      input[type="range"] {
        width: 200px;
      }
      
      .container {
        grid-template-columns: 1fr;
        padding: 15px;
      }
      
      .header {
        flex-direction: column;
        gap: 15px;
        text-align: center;
        padding: 15px;
      }
      
      .sequencer {
        min-width: unset;
        width: 100%;
      }
    }
  </style>
  </head>
  <body>
  <div class="container">
    <div class="header">
      <h1>3 Beat Problem</h1>
      <div class="bpm-control">
        <label for="bpm">BPM:</label>
        <input type="number" id="bpm" min="60" max="240" value="120" step="1">
        <button id="playPause">
          <span class="play-icon show">▶</span>
          <span class="pause-icon">⏸</span>
        </button>
        <button id="exportMidi" class="export-button">Export MIDI</button>
      </div>
    </div>
  
    <div class="sequencer" id="sequencer1">
      <div class="circle-container">
        <div class="circle">
    <div class="circle-inner-ring"></div>
    <div class="circle-middle-ring"></div>
    <div class="circle-outer-ring"></div>
    <canvas id="spectrogram1" class="spectrogram" width="180" height="180"></canvas>
  </div>
      </div>
      <div class="controls">
        <div class="control-group">
          <label for="sound1">Sound:</label>
          <select id="sound1"></select>
        </div>
        <div class="control-group">
          <label for="note1">Note:</label>
          <select id="note1"></select>
        </div>
        <div class="control-group">
          <label for="divisions1">Divisions:</label>
          <input type="number" id="divisions1" min="1" max="16" value="4" step="1">
        </div>
        <div class="volume-control">
          <label for="volume1">Volume:</label>
          <input type="range" id="volume1" min="0" max="100" value="70" step="1">
        </div>
      </div>
    </div>
  
    <div class="sequencer" id="sequencer2">
      <div class="circle-container">
        <div class="circle">
          <div class="circle-inner-ring"></div>
          <div class="circle-middle-ring"></div>
          <div class="circle-outer-ring"></div>
          <canvas id="spectrogram2" class="spectrogram" width="180" height="180"></canvas>
        </div>
      </div>
      <div class="controls">
        <div class="control-group">
          <label for="sound2">Sound:</label>
          <select id="sound2"></select>
        </div>
        <div class="control-group">
          <label for="note2">Note:</label>
          <select id="note2"></select>
        </div>
        <div class="control-group">
          <label for="divisions2">Divisions:</label>
          <input type="number" id="divisions2" min="1" max="16" value="3" step="1">
        </div>
        <div class="volume-control">
          <label for="volume2">Volume:</label>
          <input type="range" id="volume2" min="0" max="100" value="70" step="1">
        </div>
      </div>
    </div>
  
    <div class="sequencer" id="sequencer3">
      <div class="circle-container">
        <div class="circle">
          <div class="circle-inner-ring"></div>
          <div class="circle-middle-ring"></div>
          <div class="circle-outer-ring"></div>
          <canvas id="spectrogram3" class="spectrogram" width="180" height="180"></canvas>
        </div>
      </div>
      <div class="controls">
        <div class="control-group">
          <label for="sound3">Sound:</label>
          <select id="sound3"></select>
        </div>
        <div class="control-group">
          <label for="note3">Note:</label>
          <select id="note3"></select>
        </div>
        <div class="control-group">
          <label for="divisions3">Divisions:</label>
          <input type="number" id="divisions3" min="1" max="16" value="5" step="1">
        </div>
        <div class="volume-control">
          <label for="volume3">Volume:</label>
          <input type="range" id="volume3" min="0" max="100" value="70" step="1">
        </div>
      </div>
    </div>
  
    <div class="slider-container">
      <div class="slider-group">
        <label for="velocityRandomization">Velocity Randomization:</label>
        <input type="range" id="velocityRandomization" min="0" max="100" value="0" step="1">
        <span id="velocityRandomizationValue" class="value-display">0%</span>
      </div>
      <div class="slider-group">
        <label for="noteDuration">Note Duration:</label>
        <input type="range" id="noteDuration" min="0" max="100" value="50" step="1">
        <span id="noteDurationValue" class="value-display">50%</span>
      </div>
    </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
  <script>
  // Constants
  const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const OCTAVES = [3, 4, 5];
  const SOUNDS = ['sine', 'triangle', 'sawtooth', 'square', 'white', 'pink', 'brown', 'violet', 'blue'];
  const COLOR_NOISES = ['white', 'pink', 'brown', 'violet', 'blue'];
  const SOUND_TO_NOTE = {
    'white': 'C2', 
    'pink': 'E2', 
    'brown': 'G2', 
    'violet': 'B2',
    'blue': 'A2'
  };
  
  const MIDI_NOTE_MAP = {
    'C': 60, 'C#': 61, 'D': 62, 'D#': 63, 'E': 64, 'F': 65,
    'F#': 66, 'G': 67, 'G#': 68, 'A': 69, 'A#': 70, 'B': 71
  };
  
  // Add these utility functions for MIDI conversion
  function noteToMidiNumber(note) {
    if (!note) return 60; // Default to middle C if note is undefined
    const noteName = note.slice(0, -1); // Remove octave
    const octave = parseInt(note.slice(-1));
    const baseNote = MIDI_NOTE_MAP[noteName];
    if (baseNote === undefined) return 60; // Default to middle C if note name is invalid
    return baseNote + ((octave - 4) * 12); // Adjust for octave
  }
  
  function createMidiFile() {
    // Create a new MIDI file with a single track
    const midiData = {
      header: {
        format: 0, // Single track format
        numTracks: 1,
        ticksPerBeat: 480 // Standard MIDI PPQ
      },
      tracks: []
    };
  
    const bpm = parseInt(document.getElementById('bpm').value);
    const track = [];
    
    // Add track name and tempo events
    track.push({
      deltaTime: 0,
      type: 'trackName',
      text: '3 Beat Pattern'
    });
  
    track.push({
      deltaTime: 0,
      type: 'setTempo',
      microsecondsPerBeat: Math.floor(60000000 / bpm)
    });
  
    // Calculate LCM for timing
    const divisions = sequencers.map(seq => seq.divisions);
    const lcm = divisions.reduce((a, b) => (a * b) / gcd(a, b));
    
    // Get note duration from slider
    const noteDurationPercent = parseInt(document.getElementById('noteDuration').value);
    const baseDuration = Math.floor(480 * (noteDurationPercent / 100));
  
    // Create timeline of all notes
    const timeline = [];
    
    sequencers.forEach((seq, seqIndex) => {
      const stepsPerBeat = lcm / seq.divisions;
      const stepDuration = 480 / stepsPerBeat;
      
      seq.pattern.forEach((isActive, step) => {
        if (isActive) {
          // Handle note selection based on sound type
          let note;
          if (COLOR_NOISES.includes(seq.sound)) {
            // Map noise sounds to predefined notes in octave 2
            note = SOUND_TO_NOTE[seq.sound];
          } else {
            note = seq.note;
          }
          
          // Convert note to MIDI number
          const midiNote = noteToMidiNumber(note);
          
          // Apply velocity randomization
          const velocityRandom = parseInt(document.getElementById('velocityRandomization').value);
          const baseVelocity = 70;
          const velocity = Math.floor(baseVelocity + 
            (Math.random() * 2 - 1) * (velocityRandom / 100) * 57);
          
          const startTick = Math.floor(step * stepDuration);
          
          // Add note on event
          timeline.push({
            tick: startTick,
            type: 'noteOn',
            noteNumber: midiNote,
            velocity: velocity,
            channel: 0
          });
          
          // Add note off event
          timeline.push({
            tick: startTick + baseDuration,
            type: 'noteOff',
            noteNumber: midiNote,
            velocity: 0,
            channel: 0
          });
        }
      });
    });
  
    // Sort timeline by tick
    timeline.sort((a, b) => a.tick - b.tick);
    
    // Convert absolute ticks to delta time
    let lastTick = 0;
    timeline.forEach(event => {
      const deltaTime = event.tick - lastTick;
      track.push({
        deltaTime: deltaTime,
        type: event.type,
        channel: event.channel,
        noteNumber: event.noteNumber,
        velocity: event.velocity
      });
      lastTick = event.tick;
    });
  
    // Add end of track
    track.push({
      deltaTime: 0,
      type: 'endOfTrack'
    });
  
    midiData.tracks.push(track);
    return midiData;
  }
  
  // Add event listener for the export button
  document.getElementById('exportMidi').addEventListener('click', function() {
    try {
      const midiData = createMidiFile();
      const blob = generateMidiBlob(midiData);
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = '3beat-pattern.mid';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      // Show success notification
      showNotification('MIDI file exported successfully', 'success');
    } catch (error) {
      console.error('Error exporting MIDI:', error);
      showNotification('Failed to export MIDI file', 'error');
    }
  });
  
  // Add notification function
  function showNotification(message, type) {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    // Show notification
    setTimeout(() => notification.classList.add('show'), 100);
    
    // Remove notification
    setTimeout(() => {
      notification.classList.remove('show');
      setTimeout(() => notification.remove(), 300);
    }, 3000);
  }
  
  // Helper function for calculating LCM
  function lcm(a, b) {
    return (a * b) / gcd(a, b);
  }
  
  // State
  let isPlaying = false;
  let sequencers = [];
  let sequences = [];
  
  // Audio setup
  const analyzerNodes = Array(3).fill().map(() => new Tone.Analyser('fft', 512));
  const gainNodes = Array(3).fill().map(() => new Tone.Gain().toDestination());
  gainNodes.forEach(node => node.gain.value = 0.7); // Set initial volume to 70%
  
  // Connect analyzer nodes to their respective gain nodes
  analyzerNodes.forEach((analyzer, index) => gainNodes[index].connect(analyzer));
  
  // Utility functions
  const getRandomVelocity = () => {
    const randomization = parseInt(document.getElementById('velocityRandomization').value);
    return 0.7 + (Math.random() * 2 - 1) * (randomization / 100) * 0.7;
  };
  
  const getNoteDuration = () => {
    const displayValue = parseInt(document.getElementById('noteDuration').value);
    // Scale 0-100 to 1-400 
    const actualValue = 1 + (displayValue * 399/100);
    return actualValue / 400;
  };
  
  const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
  
  // UI Setup
  function populateNoteAndSoundSelects() {
    const noteSelects = ['note1', 'note2', 'note3'].map(id => document.getElementById(id));
    const soundSelects = ['sound1', 'sound2', 'sound3'].map(id => document.getElementById(id));
  
    const musicalSequence = OCTAVES.flatMap(octave => NOTES.map(note => `${note}${octave}`));
  
    noteSelects.forEach((select, index) => {
      select.innerHTML = musicalSequence.map(note => `<option value="${note}">${note}</option>`).join('');
      select.value = ['C3', 'E4', 'G5'][index];
    });
  
    soundSelects.forEach((select, index) => {
      select.innerHTML = SOUNDS.map(sound => `<option value="${sound}">${sound.charAt(0).toUpperCase() + sound.slice(1)}</option>`).join('');
      select.value = 'sine';
      
      select.addEventListener('change', (event) => {
        const noteSelect = document.getElementById(`note${index + 1}`);
        noteSelect.disabled = COLOR_NOISES.includes(event.target.value);
        if (COLOR_NOISES.includes(event.target.value)) {
          noteSelect.value = SOUND_TO_NOTE[event.target.value];
        }
      });
    });
  }
  
  function resetDotColors() {
    document.querySelectorAll('.dot').forEach(dot => {
      dot.style.backgroundColor = dot.classList.contains('active') ? 
        'var(--primary-color)' : 
        'var(--secondary-color)';
      dot.style.boxShadow = 'none';
    });
  }
  
  function createDots(sequencerId, divisions) {
    const circle = document.querySelector(`#${sequencerId} .circle`);
    if (!circle) {
      console.error(`Circle element not found for sequencer ${sequencerId}`);
      return;
    }
  
    // Clear existing content
    circle.innerHTML = '';
    
    // Add base elements in correct order
    const baseElements = `
      <div class="circle-inner-ring"></div>
      <div class="circle-middle-ring"></div>
      <div class="circle-outer-ring"></div>
      <canvas id="spectrogram${sequencerId.slice(-1)}" class="spectrogram" width="180" height="180"></canvas>
    `;
    circle.innerHTML = baseElements;
    
    // Create and append dots
    for (let i = 0; i < divisions; i++) {
      const angle = (i / divisions) * 2 * Math.PI - Math.PI / 2;
      const radius = 40;
      const dot = document.createElement('div');
      dot.className = 'dot';
      dot.dataset.index = i;
      dot.style.left = `${50 + radius * Math.cos(angle)}%`;
      dot.style.top = `${50 + radius * Math.sin(angle)}%`;
      
      // Add event listener directly to the dot element
      dot.addEventListener('click', () => {
        try {
          toggleDot(sequencerId, i);
          if (!isPlaying) {
            resetDotColors();
          }
        } catch (error) {
          console.error('Error toggling dot:', error);
        }
      });
      
      circle.appendChild(dot);
    }
  
    // Add orbiting circles after dots
    addOrbitingCircles(circle);
  }
  
  function addOrbitingCircles(circle) {
    const orbitingCircleSizes = ['small', 'medium', 'large'];
    const radiusFactors = [1.2, 1.5, 1.8]; 
    const speedFactors = [8, 12, 15]; 
    const baseRadius = 40;
  
    orbitingCircleSizes.forEach((size, index) => {
      const orbitingCircle = document.createElement('div');
      orbitingCircle.className = `orbiting-circle orbiting-circle-${size}`;
      
      const startAngle = Math.random() * Math.PI * 2;
      const orbitRadius = baseRadius * radiusFactors[index];
      
      // Update the animation to use translate(-50%, -50%) to center the circle
      const keyframes = `
        @keyframes orbit${index + 1} {
          from {
            transform: translate(-50%, -50%) rotate(${startAngle}rad) translateX(${orbitRadius}px) rotate(-${startAngle}rad);
          }
          to {
            transform: translate(-50%, -50%) rotate(${startAngle + 2 * Math.PI}rad) translateX(${orbitRadius}px) rotate(-${startAngle + 2 * Math.PI}rad);
          }
        }
      `;
  
      orbitingCircle.style.cssText = `
        width: ${8 - index}px;
        height: ${8 - index}px;
        animation: orbit${index + 1} ${speedFactors[index]}s linear infinite;
      `;
  
      // Remove any existing style with the same animation name
      const existingStyle = document.querySelector(`style[data-orbit="${index + 1}"]`);
      if (existingStyle) {
        existingStyle.remove();
      }
  
      // Add the new keyframes
      const styleSheet = document.createElement('style');
      styleSheet.setAttribute('data-orbit', index + 1);
      styleSheet.textContent = keyframes;
      document.head.appendChild(styleSheet);
  
      circle.appendChild(orbitingCircle);
    });
  }
  
  // Update the toggleDot function with error handling
  function toggleDot(sequencerId, index) {
    try {
      const sequencerIndex = parseInt(sequencerId.slice(-1)) - 1;
      const dot = document.querySelector(`#${sequencerId} .dot[data-index="${index}"]`);
      
      if (!dot) {
        console.error(`Dot element not found for sequencer ${sequencerId}, index ${index}`);
        return;
      }
      
      if (!sequencers[sequencerIndex]) {
        console.error(`Sequencer not found at index ${sequencerIndex}`);
        return;
      }
      
      dot.classList.toggle('active');
      sequencers[sequencerIndex].pattern[index] = dot.classList.contains('active');
      
      if (isPlaying) {
        updatePlayingSequencer();
      }
    } catch (error) {
      console.error('Error in toggleDot:', error);
    }
  }
  
  function updateSequencer() {
    const bpm = parseInt(document.getElementById('bpm').value);
    const notes = ['note1', 'note2', 'note3'].map(id => document.getElementById(id).value);
    const sounds = ['sound1', 'sound2', 'sound3'].map(id => document.getElementById(id).value);
    const divisions = ['divisions1', 'divisions2', 'divisions3'].map(id => parseInt(document.getElementById(id).value));
  
    // Store the old patterns if they exist
    const oldPatterns = sequencers.map(seq => seq ? [...seq.pattern] : []);
    const oldDivisions = sequencers.map(seq => seq ? seq.divisions : 0);
  
    sequencers = divisions.map((div, index) => {
      // Get the old pattern for this sequencer
      const oldPattern = oldPatterns[index] || [];
      const oldDiv = oldDivisions[index];
      
      // Create a new pattern that preserves existing dots
      let newPattern;
      if (div > oldDiv) {
        // If new divisions is larger, extend the pattern with false values
        newPattern = [...oldPattern, ...new Array(div - oldDiv).fill(false)];
      } else if (div < oldDiv) {
        // If new divisions is smaller, truncate the pattern
        newPattern = oldPattern.slice(0, div);
      } else {
        // If same number of divisions, keep existing pattern
        newPattern = oldPattern;
      }
  
      return {
        note: COLOR_NOISES.includes(sounds[index]) ? SOUND_TO_NOTE[sounds[index]] : notes[index],
        sound: sounds[index],
        divisions: div,
        pattern: newPattern.length ? newPattern : new Array(div).fill(false)
      };
    });
  
    // Update UI for each sequencer
    sequencers.forEach((seq, i) => {
      createDots(`sequencer${i + 1}`, seq.divisions);
      
      // Restore active state for dots
      seq.pattern.forEach((active, dotIndex) => {
        if (active) {
          const dot = document.querySelector(`#sequencer${i + 1} .dot[data-index="${dotIndex}"]`);
          if (dot) {
            dot.classList.add('active');
          }
        }
      });
    });
  
    if (isPlaying) {
      updatePlayingSequencer();
    }
  }
  
  function updatePlayingSequencer() {
    stopSequencer();
    startSequencer();
  }
  
  function startSequencer() {
    const bpm = parseInt(document.getElementById('bpm').value);
    Tone.Transport.bpm.value = bpm;
    
    sequences = sequencers.map((seq, index) => {
      const stepTime = 60 / (bpm * seq.divisions);
      return createSequence(seq, index, stepTime);
    });
  
    Tone.Transport.start();
    visualize();
  }
  
  function createSequence(seq, index, stepTime) {
    return new Tone.Sequence((time, step) => {
      updateDotColors(index, step);
      if (seq.pattern[step]) {
        playSound(seq, index, time, stepTime);
      }
    }, [...Array(seq.divisions).keys()], stepTime).start(0);
  }
  
  function updateDotColors(index, step) {
    document.querySelectorAll(`#sequencer${index + 1} .dot`).forEach(dot => {
      dot.style.backgroundColor = dot.classList.contains('active') ? 'var(--primary-color)' : 'var(--secondary-color)';
      dot.style.boxShadow = 'none';
    });
    const currentDot = document.querySelector(`#sequencer${index + 1} .dot:nth-child(${step + 2})`);
    if (currentDot) {
      currentDot.style.backgroundColor = sequencers[index].pattern[step] ? 'var(--primary-color)' : 'var(--tertiary-color)';
      currentDot.style.boxShadow = '0 0 10px var(--primary-color)';
    }
  }
  
  function playSound(seq, index, time, stepTime) {
    const velocity = getRandomVelocity();
    const duration = getNoteDuration() * stepTime;
    
    if (COLOR_NOISES.includes(seq.sound)) {
      let noise;
      if (seq.sound === 'violet') {
        // Create a proper violet noise by combining filters
        noise = new Tone.Noise('white');
        
        // Create a filter chain for violet noise (+6 dB/octave slope)
        const highPass1 = new Tone.Filter({
          type: 'highpass',
          frequency: 500,
          rolloff: -12
        });
        
        const highPass2 = new Tone.Filter({
          type: 'highpass',
          frequency: 1000,
          rolloff: -12
        });
        
        const highShelf = new Tone.Filter({
          type: 'highshelf',
          frequency: 2000,
          gain: 6
        });
  
        // Connect the filters in series
        noise.chain(highPass1, highPass2, highShelf, gainNodes[index]);
      } else if (seq.sound === 'blue') {
        const blueFilter = new Tone.Filter({
          type: 'highpass',
          frequency: 500,
          rolloff: -12
        });
        noise = new Tone.Noise('white').connect(blueFilter);
        blueFilter.connect(gainNodes[index]);
      } else {
        noise = new Tone.Noise(seq.sound).connect(gainNodes[index]);
      }
      noise.start(time).stop(time + duration);
    } else {
      const synthInstance = new Tone.Synth({
        oscillator: { type: seq.sound }
      }).connect(gainNodes[index]);
      synthInstance.triggerAttackRelease(seq.note, duration, time, velocity);
    }
  }
  
  function stopSequencer() {
    Tone.Transport.stop();
    sequences.forEach(seq => seq.dispose());
    resetDotColors();
    
    // Clear all spectrograms with minimal background
    document.querySelectorAll('.spectrogram').forEach(canvas => {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Create circular clip path
      ctx.save();
      ctx.beginPath();
      ctx.arc(
        canvas.width / 2,
        canvas.height / 2,
        Math.min(canvas.width, canvas.height) / 2 - 10,
        0,
        Math.PI * 2
      );
      ctx.clip();
      
      // Almost invisible background
      // ctx.fillStyle = 'rgba(0, 255, 255, 0.02)';
      // ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.restore();
    });
  }
  
  // Visualization
  function visualize() {
    if (!isPlaying) return;
    
    requestAnimationFrame(visualize);
  
    analyzerNodes.forEach((analyzer, index) => {
      const spectrogramCanvas = document.getElementById(`spectrogram${index + 1}`);
      if (!spectrogramCanvas) return;
      
      const spectrogramCtx = spectrogramCanvas.getContext('2d');
      const bufferLength = analyzer.size;
      const dataArray = analyzer.getValue();
  
      // Clear the canvas first
      spectrogramCtx.clearRect(0, 0, spectrogramCanvas.width, spectrogramCanvas.height);
  
      // Create circular clip path
      spectrogramCtx.save();
      spectrogramCtx.beginPath();
      spectrogramCtx.arc(
        spectrogramCanvas.width / 2,
        spectrogramCanvas.height / 2,
        Math.min(spectrogramCanvas.width, spectrogramCanvas.height) / 2 - 10,
        0,
        Math.PI * 2
      );
      spectrogramCtx.clip();
  
      // Draw almost invisible background
      spectrogramCtx.fillStyle = 'rgba(0, 255, 255, 0.02)';
      spectrogramCtx.fillRect(0, 0, spectrogramCanvas.width, spectrogramCanvas.height);
  
      const barWidth = (spectrogramCanvas.width / bufferLength) * 2.5;
      let x = 0;
  
      for (let i = 0; i < bufferLength; i++) {
        // Start with a very low baseline
        let value = dataArray[i];
        
        // Check if value is finite and non-null
        if (!Number.isFinite(value) || value === null) {
          value = -140; // Use minimum value instead of 0
        }
        
        // Ensure the value is properly scaled
        value = Math.max(-140, Math.min(0, value));
        
        // Scale the height more conservatively
        const barHeight = ((value + 140) / 140) * spectrogramCanvas.height * 0.8;
  
        if (barHeight > 0) {
          try {
            const gradient = spectrogramCtx.createLinearGradient(
              0,
              spectrogramCanvas.height,
              0,
              Math.max(0, spectrogramCanvas.height - barHeight)
            );
            
            // Use more subtle gradient with lower opacity
            gradient.addColorStop(0, `rgba(0, 255, 255, 0.1)`);
            gradient.addColorStop(1, `rgba(0, 255, 255, 0.4)`);
  
            spectrogramCtx.fillStyle = gradient;
            spectrogramCtx.fillRect(
              x,
              spectrogramCanvas.height - barHeight,
              barWidth,
              barHeight
            );
          } catch (error) {
            console.warn('Visualization error:', error);
            spectrogramCtx.fillStyle = 'rgba(0, 255, 255, 0.2)';
            spectrogramCtx.fillRect(
              x,
              spectrogramCanvas.height - barHeight,
              barWidth,
              barHeight
            );
          }
        }
  
        x += barWidth + 1;
      }
      
      spectrogramCtx.restore();
    });
  }
  
  // Make sure the spectrograms are cleared on app start
  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.spectrogram').forEach(canvas => {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Create circular clip path
      ctx.save();
      ctx.beginPath();
      ctx.arc(
        canvas.width / 2,
        canvas.height / 2,
        Math.min(canvas.width, canvas.height) / 2 - 10,
        0,
        Math.PI * 2
      );
      ctx.clip();
      
      // Almost invisible background
      // ctx.fillStyle = 'rgba(0, 255, 255, 0.02)';
      // ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.restore();
    });
    
    populateNoteAndSoundSelects();
    updateSequencer();
  });
  
  // Event handlers
  function togglePlayPause() {
    if (Tone.context.state !== 'running') {
      Tone.context.resume().then(playPauseAction);
    } else {
      playPauseAction();
    }
    
    // Toggle icons
    document.querySelector('.play-icon').classList.toggle('show');
    document.querySelector('.pause-icon').classList.toggle('show');
  }
  
  function playPauseAction() {
    isPlaying = !isPlaying;
    
    if (isPlaying) {
      startSequencer();
    } else {
      stopSequencer();
    }
  }
  
  // Add MIDI file creation and download functionality
  function generateMidiBlob(midiData) {
    // Simple MIDI file writer
    const writeMidiFile = function(data) {
      const buffer = new ArrayBuffer(data.length);
      const view = new Uint8Array(buffer);
      for (let i = 0; i < data.length; i++) {
        view[i] = data[i];
      }
      return buffer;
    };
  
    const writeVarLength = function(value) {
      let bytes = [];
      let currentByte;
  
      do {
        currentByte = value & 0x7F;
        value >>= 7;
        if (value) currentByte |= 0x80;
        bytes.push(currentByte);
      } while (value);
  
      return bytes;
    };
  
    const writeInt16 = function(value) {
      return [(value >> 8) & 0xFF, value & 0xFF];
    };
  
    const writeInt32 = function(value) {
      return [
        (value >> 24) & 0xFF,
        (value >> 16) & 0xFF,
        (value >> 8) & 0xFF,
        value & 0xFF
      ];
    };
  
    // Write header chunk
    let data = [
      0x4D, 0x54, 0x68, 0x64, // MThd
      ...writeInt32(6), // Header size
      ...writeInt16(midiData.header.format),
      ...writeInt16(midiData.header.numTracks),
      ...writeInt16(midiData.header.ticksPerBeat)
    ];
  
    // Write track chunk
    const track = midiData.tracks[0];
    let trackData = [];
  
    // Write track events
    track.forEach(event => {
      // Write delta time
      trackData.push(...writeVarLength(event.deltaTime));
  
      // Write event data based on type
      switch(event.type) {
        case 'noteOn':
          trackData.push(0x90 | event.channel); // Note On
          trackData.push(event.noteNumber);
          trackData.push(event.velocity);
          break;
        case 'noteOff':
          trackData.push(0x80 | event.channel); // Note Off
          trackData.push(event.noteNumber);
          trackData.push(event.velocity);
          break;
        case 'setTempo':
          trackData.push(0xFF); // Meta event
          trackData.push(0x51); // Tempo
          trackData.push(0x03); // Length
          trackData.push(...writeInt32(event.microsecondsPerBeat).slice(1));
          break;
        case 'endOfTrack':
          trackData.push(0xFF, 0x2F, 0x00);
          break;
      }
    });
  
    // Add track chunk header
    data.push(
      0x4D, 0x54, 0x72, 0x6B, // MTrk
      ...writeInt32(trackData.length)
    );
    // Add track data
    data.push(...trackData);
  
    return new Blob([writeMidiFile(data)], {type: 'audio/midi'});
  }
  
  // Event listeners
  document.getElementById('playPause').addEventListener('click', togglePlayPause);
  
  document.getElementById('bpm').addEventListener('input', () => {
    const bpm = parseInt(document.getElementById('bpm').value);
    Tone.Transport.bpm.value = bpm;
    if (isPlaying) {
      stopSequencer();
      startSequencer();
    }
  });
  
  ['note1', 'note2', 'note3', 'sound1', 'sound2', 'sound3', 'divisions1', 'divisions2', 'divisions3'].forEach(id => {
    document.getElementById(id).addEventListener('change', updateSequencer);
  });
  
  document.querySelectorAll('[id^="volume"]').forEach((slider, index) => {
    slider.addEventListener('input', function() {
      gainNodes[index].gain.value = this.value / 100;
    });
  });
  
  document.getElementById('velocityRandomization').addEventListener('input', function() {
    document.getElementById('velocityRandomizationValue').textContent = this.value + '%';
  });
  
  document.getElementById('noteDuration').addEventListener('input', function() {
    document.getElementById('noteDurationValue').textContent = this.value + '%';
  });
  </script>
  
  </body></html>