<html><head><base href="https://3beatproblem.websim.io/"><title>3 Beat Problem</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg-color: #0a1019;
    --primary-color: #00fff0; /* Slightly adjusted cyan */
    --secondary-color: #ff34b3; /* Softer magenta */
    --tertiary-color: #ffd700; /* More golden yellow */
    --text-color: #ffffff;
    --control-bg: rgba(255, 255, 255, 0.12);
    --slider-bg: rgba(255, 255, 255, 0.25);
    --select-bg: #1a1f2e;
    --success-color: #4CAF50;
    --error-color: #f44336;
  }

  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  body {
    font-family: 'Roboto', sans-serif;
    background: linear-gradient(135deg, #0a0e17 0%, #1a1e2e 100%);
    color: var(--text-color);
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    overflow-x: hidden;
  }

  .container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 30px;
    background: rgba(255, 255, 255, 0.07);
    padding: 30px;
    border-radius: 20px;
    box-shadow: 0 8px 32px rgba(0, 255, 255, 0.15);
    backdrop-filter: blur(15px);
    max-width: 1200px;
    width: 95%;
    margin: 20px auto;
  }

  .header {
    grid-column: 1 / -1;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 30px;
    margin: -30px -30px 30px -30px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 20px 20px 0 0;
  }

  h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: 28px;
    font-weight: 700;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--primary-color);
    text-shadow: 0 0 10px var(--primary-color);
  }

  .bpm-control {
    display: flex;
    align-items: center;
    background: var(--control-bg);
    padding: 5px 10px;
    border-radius: 15px;
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
  }

  .bpm-control label {
    margin-right: 10px;
    font-size: 14px;
    font-family: 'Orbitron', sans-serif;
  }

  .sequencer {
    min-width: 280px;
    height: auto;
    aspect-ratio: 1;
    padding: 25px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    gap: 20px;
  }

  .circle-container {
    width: 180px;
    height: 180px;
    margin: 0 auto;
  }

  .circle {
    width: 100%;
    height: 100%;
    border: 2px solid var(--primary-color);
    border-radius: 50%;
    position: relative;
    transition: all 0.3s ease;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
  }

  .dot {
    width: 12px;
    height: 12px;
    background-color: var(--secondary-color);
    border-radius: 50%;
    position: absolute;
    transform: translate(-50%, -50%);
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .dot.active {
    background-color: var(--primary-color);
    box-shadow: 0 0 15px var(--primary-color);
  }

  .controls {
    width: 100%;
    display: grid;
    grid-template-columns: 1fr;
    gap: 15px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 15px;
  }

  label {
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--tertiary-color);
    font-family: 'Orbitron', sans-serif;
  }

  select, input[type="number"] {
    background-color: var(--select-bg);
    color: var(--text-color);
    border: 1px solid rgba(255, 255, 255, 0.2);
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 14px;
    transition: all 0.3s ease;
  }

  select:hover, input[type="number"]:hover {
    border-color: var(--primary-color);
  }

  .slider-container {
    grid-column: 1 / -1;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 30px;
    padding: 20px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 15px;
    margin-top: 20px;
  }

  .slider-group {
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  input[type="range"] {
    height: 8px;
    background: linear-gradient(90deg, var(--primary-color) 0%, var(--secondary-color) 100%);
    border-radius: 4px;
  }

  input[type="range"]::-webkit-slider-thumb {
    width: 20px;
    height: 20px;
    background: var(--tertiary-color);
    border: 2px solid var(--primary-color);
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    -webkit-appearance: none;
  }

  .button-group {
    grid-column: 1 / -1;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 20px;
    margin-top: 30px;
  }

  button {
    min-width: 150px;
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    color: var(--bg-color);
    font-weight: 600;
    padding: 15px 30px;
    border-radius: 25px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    border: none;
    transition: all 0.3s ease;
  }

  button:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 15px rgba(0, 255, 255, 0.3);
  }

  #abcOutput {
    grid-column: 1 / -1;
    margin-top: 30px;
    padding: 20px;
    max-height: 400px;
    background: rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 12px;
    font-family: 'Roboto Mono', monospace;
    line-height: 1.5;
    font-size: 12px;
    overflow-y: auto;
  }

  .spectrogram {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 80px;
    height: 80px;
    background-color: rgba(0, 0, 0, 0.5);
    border-radius: 50%;
    overflow: hidden;
  }

  .orbiting-circle {
    position: absolute;
    border-radius: 50%;
    border: 1px solid var(--primary-color);
    box-shadow: 0 0 5px var(--primary-color);
    opacity: 0.7;
    pointer-events: none;
  }

  .orbiting-circle-small {
    width: 8px;
    height: 8px;
  }

  .orbiting-circle-medium {
    width: 12px;
    height: 12px;
  }

  .orbiting-circle-large {
    width: 16px;
    height: 16px;
  }

  .abc-block {
    margin-bottom: 10px;
    position: relative;
  }

  .copy-button {
    position: absolute;
    right: 5px;
    bottom: 5px;
    font-size: 12px;
    padding: 6px 12px;
    opacity: 0;
    transition: all 0.3s ease;
  }

  .abc-block:hover .copy-button {
    opacity: 1;
  }

  @media (max-width: 1200px) {
    .container {
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      padding: 20px;
    }
    
    .circle-container {
      width: 150px;
      height: 150px;
    }
  }

  @media (max-width: 768px) {
    .container {
      grid-template-columns: 1fr;
      padding: 15px;
    }
    
    .header {
      flex-direction: column;
      gap: 15px;
      text-align: center;
      padding: 15px;
    }
    
    .sequencer {
      min-width: unset;
      width: 100%;
    }
    
    .slider-container {
      grid-template-columns: 1fr;
    }
    
    .button-group {
      flex-direction: column;
    }
    
    button {
      width: 100%;
    }
  }

  .notification {
    position: fixed;
    bottom: 20px;
    right: 20px;
    padding: 15px 25px;
    border-radius: 8px;
    color: white;
    font-weight: 500;
    opacity: 0;
    transform: translateY(20px);
    transition: all 0.3s ease;
  }

  .notification.show {
    opacity: 1;
    transform: translateY(0);
  }

  .notification.success {
    background-color: var(--success-color);
  }

  .notification.error {
    background-color: var(--error-color);
  }
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>3 Beat Problem</h1>
    <div class="bpm-control">
      <label for="bpm">BPM:</label>
      <input type="number" id="bpm" min="60" max="240" value="120" step="1">
    </div>
  </div>

  <div class="sequencer" id="sequencer1">
    <div class="circle-container">
      <div class="circle">
        <canvas id="spectrogram1" class="spectrogram" width="80" height="80"></canvas>
      </div>
    </div>
    <div class="controls">
      <div class="control-group">
        <label for="sound1">Sound:</label>
        <select id="sound1"></select>
      </div>
      <div class="control-group">
        <label for="note1">Note:</label>
        <select id="note1"></select>
      </div>
      <div class="control-group">
        <label for="divisions1">Divisions:</label>
        <input type="number" id="divisions1" min="1" max="16" value="4" step="1">
      </div>
    </div>
  </div>

  <div class="sequencer" id="sequencer2">
    <div class="circle-container">
      <div class="circle">
        <canvas id="spectrogram2" class="spectrogram" width="80" height="80"></canvas>
      </div>
    </div>
    <div class="controls">
      <div class="control-group">
        <label for="sound2">Sound:</label>
        <select id="sound2"></select>
      </div>
      <div class="control-group">
        <label for="note2">Note:</label>
        <select id="note2"></select>
      </div>
      <div class="control-group">
        <label for="divisions2">Divisions:</label>
        <input type="number" id="divisions2" min="1" max="16" value="3" step="1">
      </div>
    </div>
  </div>

  <div class="sequencer" id="sequencer3">
    <div class="circle-container">
      <div class="circle">
        <canvas id="spectrogram3" class="spectrogram" width="80" height="80"></canvas>
      </div>
    </div>
    <div class="controls">
      <div class="control-group">
        <label for="sound3">Sound:</label>
        <select id="sound3"></select>
      </div>
      <div class="control-group">
        <label for="note3">Note:</label>
        <select id="note3"></select>
      </div>
      <div class="control-group">
        <label for="divisions3">Divisions:</label>
        <input type="number" id="divisions3" min="1" max="16" value="5" step="1">
      </div>
    </div>
  </div>

  <div class="slider-container">
    <div class="slider-group">
      <label for="velocityRandomization">Velocity Randomization:</label>
      <input type="range" id="velocityRandomization" min="0" max="100" value="0" step="1">
      <span id="velocityRandomizationValue" class="value-display">0%</span>
    </div>
    <div class="slider-group">
      <label for="noteDuration">Note Duration:</label>
      <input type="range" id="noteDuration" min="1" max="200" value="50" step="1">
      <span id="noteDurationValue" class="value-display">50%</span>
    </div>
  </div>

  <div class="button-group">
    <button id="playPause">Play/Pause</button>
    <button id="generateAbc">Generate ABC</button>
    <button id="abcToMidi" onclick="window.open('https://notabc.app/abc-converter/', '_blank')">ABC to MIDI</button>
  </div>

  <div id="abcOutput"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<script>
// Constants
const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
const OCTAVES = [3, 4, 5];
const SOUNDS = ['sine', 'triangle', 'sawtooth', 'square', 'white', 'pink', 'brown', 'violet', 'blue'];
const COLOR_NOISES = ['white', 'pink', 'brown', 'violet', 'blue'];
const SOUND_TO_NOTE = {
  'white': 'C4', 'pink': 'E4', 'brown': 'G4', 'violet': 'B4', 'blue': 'A4'
};

// State
let isPlaying = false;
let sequencers = [];
let sequences = [];

// Audio setup
const analyzerNodes = Array(3).fill().map(() => new Tone.Analyser('fft', 512));
const gainNodes = Array(3).fill().map(() => new Tone.Gain().toDestination());

// Connect analyzer nodes to their respective gain nodes
analyzerNodes.forEach((analyzer, index) => gainNodes[index].connect(analyzer));

// Utility functions
const getRandomVelocity = () => {
  const randomization = parseInt(document.getElementById('velocityRandomization').value);
  return 0.7 + (Math.random() * 2 - 1) * (randomization / 100) * 0.7;
};

const getNoteDuration = () => parseInt(document.getElementById('noteDuration').value) / 100;

const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);

// UI Setup
function populateNoteAndSoundSelects() {
  const noteSelects = ['note1', 'note2', 'note3'].map(id => document.getElementById(id));
  const soundSelects = ['sound1', 'sound2', 'sound3'].map(id => document.getElementById(id));

  const musicalSequence = OCTAVES.flatMap(octave => NOTES.map(note => `${note}${octave}`));

  noteSelects.forEach((select, index) => {
    select.innerHTML = musicalSequence.map(note => `<option value="${note}">${note}</option>`).join('');
    select.value = ['C3', 'E4', 'G5'][index];
  });

  soundSelects.forEach((select, index) => {
    select.innerHTML = SOUNDS.map(sound => `<option value="${sound}">${sound.charAt(0).toUpperCase() + sound.slice(1)}</option>`).join('');
    select.value = 'sine';
    
    select.addEventListener('change', (event) => {
      const noteSelect = document.getElementById(`note${index + 1}`);
      noteSelect.disabled = COLOR_NOISES.includes(event.target.value);
      if (COLOR_NOISES.includes(event.target.value)) {
        noteSelect.value = SOUND_TO_NOTE[event.target.value];
      }
    });
  });
}

function createDots(sequencerId, divisions) {
  const circle = document.querySelector(`#${sequencerId} .circle`);
  circle.innerHTML = `<canvas id="spectrogram${sequencerId.slice(-1)}" class="spectrogram" width="80" height="80"></canvas>`;
  circle.innerHTML += Array.from({length: divisions}, (_, i) => {
    const angle = (i / divisions) * 2 * Math.PI - Math.PI / 2;
    const radius = 40;
    return `<div class="dot" style="left: ${50 + radius * Math.cos(angle)}%; top: ${50 + radius * Math.sin(angle)}%;" data-index="${i}"></div>`;
  }).join('');

  circle.querySelectorAll('.dot').forEach(dot => {
    dot.addEventListener('click', () => {
      toggleDot(sequencerId, parseInt(dot.dataset.index));
      if (!isPlaying) {
        resetDotColors();
      }
    });
  });

  addOrbitingCircles(circle);
}

function addOrbitingCircles(circle) {
  const orbitingCircles = [
    { class: 'orbiting-circle-small', speed: 2, radius: 25 },
    { class: 'orbiting-circle-medium', speed: 1.5, radius: 30 },
    { class: 'orbiting-circle-large', speed: 1, radius: 35 }
  ];

  orbitingCircles.forEach((circleData, index) => {
    const orbitingCircle = document.createElement('div');
    orbitingCircle.className = `orbiting-circle ${circleData.class}`;
    circle.appendChild(orbitingCircle);

    let angle = (2 * Math.PI / 3) * index;
    function animate() {
      angle += 0.01 * circleData.speed;
      const x = 50 + circleData.radius * Math.cos(angle);
      const y = 50 + circleData.radius * Math.sin(angle);
      orbitingCircle.style.left = `${x}%`;
      orbitingCircle.style.top = `${y}%`;
      requestAnimationFrame(animate);
    }
    animate();
  });
}

// Sequencer logic
function toggleDot(sequencerId, index) {
  const sequencerIndex = parseInt(sequencerId.slice(-1)) - 1;
  const dot = document.querySelector(`#${sequencerId} .dot:nth-child(${index + 2})`);
  dot.classList.toggle('active');
  sequencers[sequencerIndex].pattern[index] = dot.classList.contains('active');
  if (isPlaying) updatePlayingSequencer();
}

function updateSequencer() {
  const bpm = parseInt(document.getElementById('bpm').value);
  const notes = ['note1', 'note2', 'note3'].map(id => document.getElementById(id).value);
  const sounds = ['sound1', 'sound2', 'sound3'].map(id => document.getElementById(id).value);
  const divisions = ['divisions1', 'divisions2', 'divisions3'].map(id => parseInt(document.getElementById(id).value));

  sequencers = divisions.map((div, index) => ({
    note: COLOR_NOISES.includes(sounds[index]) ? SOUND_TO_NOTE[sounds[index]] : notes[index],
    sound: sounds[index],
    divisions: div,
    pattern: sequencers[index] ? 
      sequencers[index].pattern.slice(0, div).concat(new Array(Math.max(0, div - sequencers[index].pattern.length)).fill(false)) : 
      new Array(div).fill(false)
  }));

  sequencers.forEach((seq, i) => {
    createDots(`sequencer${i + 1}`, seq.divisions);
    seq.pattern.forEach((active, dotIndex) => {
      const dot = document.querySelector(`#sequencer${i + 1} .dot:nth-child(${dotIndex + 2})`);
      if (dot) dot.classList.toggle('active', active);
    });
  });

  if (isPlaying) updatePlayingSequencer();
}

function updatePlayingSequencer() {
  stopSequencer();
  startSequencer();
}

function startSequencer() {
  const bpm = parseInt(document.getElementById('bpm').value);
  Tone.Transport.bpm.value = bpm;
  
  sequences = sequencers.map((seq, index) => {
    const stepTime = 60 / (bpm * seq.divisions);
    return createSequence(seq, index, stepTime);
  });

  Tone.Transport.start();
  visualize();
}

function createSequence(seq, index, stepTime) {
  return new Tone.Sequence((time, step) => {
    updateDotColors(index, step);
    if (seq.pattern[step]) {
      playSound(seq, index, time, stepTime);
    }
  }, [...Array(seq.divisions).keys()], stepTime).start(0);
}

function updateDotColors(index, step) {
  document.querySelectorAll(`#sequencer${index + 1} .dot`).forEach(dot => {
    dot.style.backgroundColor = dot.classList.contains('active') ? 'var(--primary-color)' : 'var(--secondary-color)';
    dot.style.boxShadow = 'none';
  });
  const currentDot = document.querySelector(`#sequencer${index + 1} .dot:nth-child(${step + 2})`);
  if (currentDot) {
    currentDot.style.backgroundColor = sequencers[index].pattern[step] ? 'var(--primary-color)' : 'var(--tertiary-color)';
    currentDot.style.boxShadow = '0 0 10px var(--primary-color)';
  }
}

function playSound(seq, index, time, stepTime) {
  const velocity = getRandomVelocity();
  const duration = getNoteDuration() * stepTime;
  
  if (COLOR_NOISES.includes(seq.sound)) {
    let noise;
    if (seq.sound === 'violet') {
      const violetFilter = new Tone.Filter({
        type: 'highpass',
        frequency: 1000,
        rolloff: -6
      });
      noise = new Tone.Noise('white').connect(violetFilter);
      violetFilter.connect(gainNodes[index]);
    } else if (seq.sound === 'blue') {
      const blueFilter = new Tone.Filter({
        type: 'highpass',
        frequency: 500,
        rolloff: -12
      });
      noise = new Tone.Noise('white').connect(blueFilter);
      blueFilter.connect(gainNodes[index]);
    } else {
      noise = new Tone.Noise(seq.sound).connect(gainNodes[index]);
    }
    noise.start(time).stop(time + duration);
  } else {
    const synthInstance = new Tone.Synth({
      oscillator: { type: seq.sound }
    }).connect(gainNodes[index]);
    synthInstance.triggerAttackRelease(seq.note, duration, time, velocity);
  }
}

function stopSequencer() {
  Tone.Transport.stop();
  sequences.forEach(seq => seq.dispose());
  resetDotColors();
  document.querySelectorAll('.spectrogram').forEach(canvas => {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  });
}

function resetDotColors() {
  document.querySelectorAll('.dot').forEach(dot => {
    dot.style.backgroundColor = dot.classList.contains('active') ? 'var(--primary-color)' : 'var(--secondary-color)';
    dot.style.boxShadow = 'none';
  });
}

// ABC Notation
function generateAbc() {
  const bpm = parseInt(document.getElementById('bpm').value);
  let abcNotation = '';

  sequencers.forEach((seq, index) => {
    abcNotation += generateSequencerAbc(seq, index, bpm);
  });

  displayAbcNotation(abcNotation);
  return abcNotation;
}

function generateSequencerAbc(seq, index, bpm) {
  const sequencerName = ['First', 'Second', 'Third'][index];
  let abcNotation = `X:${index + 1}\n`;
  abcNotation += `T:${sequencerName} Sequencer\n`;
  abcNotation += `M:${seq.divisions}/4\n`;
  abcNotation += `L:1/4\n`;
  abcNotation += `Q:1/4=${bpm}\n`;
  abcNotation += `K:C\n`;

  for (let bar = 0; bar < 4; bar++) {
    for (let beat = 0; beat < seq.divisions; beat++) {
      const patternIndex = (bar * seq.divisions + beat) % seq.divisions;
      if (seq.pattern[patternIndex]) {
        let note = COLOR_NOISES.includes(seq.sound) ? 'C' : seq.note.replace(/(\d+)/, '');
        abcNotation += note;
      } else {
        abcNotation += 'z';
      }
    }
    abcNotation += '|';
  }
  abcNotation += '\n\n';
  return abcNotation;
}

function displayAbcNotation(abcNotation) {
  const abcOutput = document.getElementById('abcOutput');
  abcOutput.innerHTML = '';

  const abcBlocks = abcNotation.trim().split('\n\n');
  abcBlocks.forEach((block, index) => {
    const blockDiv = document.createElement('div');
    blockDiv.className = 'abc-block';
    blockDiv.textContent = block;

    const copyButton = document.createElement('button');
    copyButton.textContent = 'Copy';
    copyButton.className = 'copy-button';
    copyButton.onclick = () => copyAbcBlock(block);

    blockDiv.appendChild(copyButton);
    abcOutput.appendChild(blockDiv);
  });
}

function copyAbcBlock(text) {
  navigator.clipboard.writeText(text).then(() => {
    alert('ABC notation block copied to clipboard!');
  }, (err) => {
    console.error('Could not copy text: ', err);
  });
}

// Visualization
function visualize() {
  if (!isPlaying) return;
  
  requestAnimationFrame(visualize);

  analyzerNodes.forEach((analyzer, index) => {
    const spectrogramCanvas = document.getElementById(`spectrogram${index + 1}`);
    if (!spectrogramCanvas) return;
    
    const spectrogramCtx = spectrogramCanvas.getContext('2d');
    const bufferLength = analyzer.size;
    const dataArray = analyzer.getValue();

    spectrogramCtx.clearRect(0, 0, spectrogramCanvas.width, spectrogramCanvas.height);

    const barWidth = (spectrogramCanvas.width / bufferLength) * 2.5;
    let x = 0;

    for (let i = 0; i < bufferLength; i++) {
      // Clamp and sanitize the value
      let value = dataArray[i];
      
      // Check if value is finite, if not use 0
      if (!Number.isFinite(value)) {
        value = 0;
      }
      
      // Clamp the value between -140 and 0
      value = Math.max(-140, Math.min(0, value));
      
      // Calculate bar height with clamped values
      const barHeight = Math.max(0, Math.min(spectrogramCanvas.height, (value + 140) * 1.5));

      try {
        const gradient = spectrogramCtx.createLinearGradient(
          0,
          spectrogramCanvas.height,
          0,
          Math.max(0, spectrogramCanvas.height - barHeight)
        );
        
        gradient.addColorStop(0, `rgba(0, 255, 255, 0.1)`);
        gradient.addColorStop(1, `rgba(0, 255, 255, 0.8)`);

        spectrogramCtx.fillStyle = gradient;
        spectrogramCtx.fillRect(
          x,
          spectrogramCanvas.height - barHeight,
          barWidth,
          barHeight
        );
      } catch (error) {
        console.warn('Visualization error:', error);
        // Use a fallback solid color if gradient fails
        spectrogramCtx.fillStyle = 'rgba(0, 255, 255, 0.5)';
        spectrogramCtx.fillRect(
          x,
          spectrogramCanvas.height - barHeight,
          barWidth,
          barHeight
        );
      }

      x += barWidth + 1;
    }
  });
}

// Event handlers
function togglePlayPause() {
  if (Tone.context.state !== 'running') {
    Tone.context.resume().then(playPauseAction);
  } else {
    playPauseAction();
  }
}

function playPauseAction() {
  isPlaying = !isPlaying;
  
  if (isPlaying) {
    startSequencer();
  } else {
    stopSequencer();
  }
}

// Event listeners
document.getElementById('playPause').addEventListener('click', togglePlayPause);

document.getElementById('bpm').addEventListener('input', () => {
  const bpm = parseInt(document.getElementById('bpm').value);
  Tone.Transport.bpm.value = bpm;
  if (isPlaying) {
    stopSequencer();
    startSequencer();
  }
});

['note1', 'note2', 'note3', 'sound1', 'sound2', 'sound3', 'divisions1', 'divisions2', 'divisions3'].forEach(id => {
  document.getElementById(id).addEventListener('change', updateSequencer);
});

document.getElementById('velocityRandomization').addEventListener('input', function() {
  document.getElementById('velocityRandomizationValue').textContent = this.value + '%';
});

document.getElementById('noteDuration').addEventListener('input', function() {
  document.getElementById('noteDurationValue').textContent = this.value + '%';
});

document.getElementById('generateAbc').addEventListener('click', generateAbc);

// Initialize the app
populateNoteAndSoundSelects();
updateSequencer();
</script>
</body>
</html>