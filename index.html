<html><head><base href="https://">
  <title>3 Beat Problem</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&amp;family=Roboto:wght@300;400;700&amp;display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-color: #0a1019;
      --primary-color: #00fff0; /* Slightly adjusted cyan */
      --secondary-color: #ff34b3; /* Softer magenta */
      --tertiary-color: #ffd700; /* More golden yellow */
      --text-color: #ffffff;
      --control-bg: rgba(255, 255, 255, 0.12);
      --slider-bg: rgba(255, 255, 255, 0.25);
      --select-bg: #1a1f2e;
      --success-color: var(--primary-color);
      --error-color: var(--secondary-color);
    }
  
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
  
    body {
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(135deg, #0a0e17 0%, #1a1e2e 100%);
      color: var(--text-color);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      width: 100%;
    }
  
    .container {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      gap: 2rem;
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
      position: relative;
    }
  
    .header {
      flex: 1 0 100%;
      margin: 0 0 2rem 0;
      padding: 1.5rem;
      padding-top: 0.5rem;  /* Reduce top padding */
      gap: 1.5rem;         /* Add consistent gap */
      border-radius: 20px;
      background: rgba(0, 0, 0, 0.3);
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
  
    h1 {
      color: var(--primary-color);
      text-shadow: 0 0 10px var(--primary-color);
      font-family: 'Orbitron', sans-serif;
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
  
    .bpm-control {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: auto;    
    }
  
    .bpm-control label {
      margin-right: 10px;
      font-size: 14px;
      font-family: 'Orbitron', sans-serif;
    }
  
    #bpm {
      color: var(--primary-color);
      width: 60px;
      text-align: center;
      background: var(--select-bg);
      border: 1px solid rgba(0, 255, 240, 0.3);
      padding: 4px;
      font-size: 16px;
      border-radius: 4px;
      transition: all 0.3s ease;
    }
  
    #bpm:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 10px rgba(0, 255, 240, 0.2);
    }
  
    #bpm.invalid {
      color: var(--secondary-color);
      border-color: var(--secondary-color);
    }
  
    #playPause {
      min-width: unset;
      width: auto;
      height: auto;
      padding: 8px;
      border-radius: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      color: var(--primary-color);
      font-size: 24px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
  
    #playPause:hover {
      transform: scale(1.1);
      color: var(--secondary-color);
      box-shadow: none;
    }
  
    #playPause:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
      color: var(--text-color);
    }
  
    .play-icon, .pause-icon {
      display: none;
    }
  
    .play-icon.show, .pause-icon.show {
      display: block;
    }
  
    .export-button {
      background: var(--tertiary-color);
      color: var(--bg-color);
      border: none;
      padding: 8px 15px;
      border-radius: 20px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
      transition: all 0.3s ease;
      margin-left: 10px;
    }
  
    .export-button:hover {
      background: var(--primary-color);
    }
  
    .sequencer {
      flex: 0 1 300px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      margin: 0;
      padding: 1rem;
    }
  
    .circle-container {
      width: min(180px, 30vw);
      height: min(180px, 30vw);
      aspect-ratio: 1;
      margin: 0 auto;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      transform: translateZ(0);
    }
  
    .circle {
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 50%;
      position: relative;
      transition: all 0.3s ease;
      background: radial-gradient(
        circle at center,
        rgba(0,0,0,0.95) 0%,
        rgba(10,16,25,0.9) 40%,
        rgba(26,31,46,0.85) 80%,
        rgba(0,255,240,0.15) 100%
      );
      backdrop-filter: blur(10px);
      box-shadow: 
        0 0 40px rgba(0,255,240,0.15),
        inset 0 0 30px rgba(255,52,179,0.1);
      animation: pulseMain 6s ease-in-out infinite;
    }
  
    .circle::before {
      content: '';
      position: absolute;
      inset: -3px;
      background: conic-gradient(
        from 45deg,
        rgba(0,255,240,0.8),
        rgba(255,52,179,0.8),
        rgba(255,215,0,0.8),
        rgba(0,255,240,0.8)
      );
      border-radius: 50%;
      -webkit-mask: 
        linear-gradient(#fff 0 0) content-box, 
        linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask: 
        linear-gradient(#fff 0 0) content-box, 
        linear-gradient(#fff 0 0);
      mask-composite: exclude;
      padding: 3px;
      animation: spinGradient 12s linear infinite;
      opacity: 0.8;
    }
  
    .circle-inner-ring,
    .circle-middle-ring,
    .circle-outer-ring {
      position: absolute;
      border-radius: 50%;
      border: 2px solid transparent;
      transform-origin: center;
    }
  
    .circle-inner-ring {
      inset: 20%;
      border-image: linear-gradient(45deg, rgba(0,255,240,0.7), transparent) 1;
      animation: spinCounterClockwise 15s linear infinite;
    }
  
    .circle-middle-ring {
      inset: 35%;
      border-image: linear-gradient(135deg, rgba(255,52,179,0.7), transparent) 1;
      animation: spin 10s linear infinite;
    }
  
    .circle-outer-ring {
      inset: 50%;
      border-image: linear-gradient(225deg, rgba(255,215,0,0.7), transparent) 1;
      animation: spinCounterClockwise 20s linear infinite;
    }
  
    .dot {
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, 
        var(--secondary-color) 0%, 
        var(--secondary-color) 100%
      );
      border-radius: 50%;
      position: absolute;
      transform: translate(-50%, -50%);
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 
        0 0 15px rgba(255,52,179,0.4),
        inset 0 0 8px rgba(255,255,255,0.8);
      z-index: 2; /* Ensure dots stay above the visualizer */
    }
  
    .dot::before {
      content: '';
      position: absolute;
      inset: -3px;
      background: conic-gradient(
        from 45deg,
        rgba(0,255,240,0.9),
        rgba(255,52,179,0.9),
        rgba(0,255,240,0.9)
      );
      border-radius: inherit;
      animation: spinGradient 6s linear infinite;
      opacity: 0;
      transition: opacity 0.4s ease;
    }
  
    .dot:hover::before {
      opacity: 1;
    }
  
    .dot:hover {
      transform: translate(-50%, -50%) scale(1.2);
      box-shadow: 
        0 0 25px rgba(255,52,179,0.6),
        inset 0 0 12px rgba(255,255,255,0.9);
    }
  
    .dot.active {
      background: linear-gradient(135deg, 
        var(--primary-color) 0%, 
        var(--primary-color) 100%
      );
      box-shadow: 
        0 0 35px var(--primary-color),
        0 0 50px var(--primary-color),
        inset 0 0 20px rgba(255,255,255,0.9);
      animation: activePulse 2s ease-in-out infinite;
    }
  
    .spectrogram {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;  
      display: block;
      margin: auto;
      background: transparent;
    }
  
    .volume-control {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
  
    .volume-control label {
      min-width: 60px;
      font-size: 12px;
    }
  
    .volume-control input[type="range"] {
      width: 100px;
      height: 4px;
    }
  
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 150px;
      height: 6px;
      background: linear-gradient(90deg, var(--primary-color) 0%, var(--secondary-color) 100%);
      border-radius: 3px;
    }
  
    /* Update the slider thumb styles */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--primary-color); /* Cyan center */
      border: 2px solid var(--tertiary-color); /* Yellow border */
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
      cursor: pointer;
      transition: all 0.3s ease;
    }
  
    /* For Firefox */
    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--primary-color); /* Cyan center */
      border: 2px solid var(--tertiary-color); /* Yellow border */
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
      cursor: pointer;
      transition: all 0.3s ease;
    }
  
    /* For Edge/IE */
    input[type="range"]::-ms-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--primary-color); /* Cyan center */
      border: 2px solid var(--tertiary-color); /* Yellow border */
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
      cursor: pointer;
      transition: all 0.3s ease;
    }
  
    @keyframes pulseMain {
      0%, 100% {
        box-shadow: 
          0 0 40px rgba(0,255,240,0.15),
          inset 0 0 30px rgba(255,52,179,0.1);
        filter: brightness(1);
      }
      50% {
        box-shadow: 
          0 0 60px rgba(0,255,240,0.25),
          inset 0 0 45px rgba(255,52,179,0.2);
        filter: brightness(1.3);
      }
    }
  
    @keyframes spinGradient {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  
    @keyframes spinCounterClockwise {
      0% { transform: rotate(360deg); }
      100% { transform: rotate(0deg); }
    }
  
    @keyframes activePulse {
      0%, 100% {
        transform: translate(-50%, -50%) scale(1);
        box-shadow: 
          0 0 35px rgba(0,255,240,0.6),
          0 0 50px rgba(0,255,240,0.4),
          inset 0 0 20px rgba(255,255,255,0.9);
      }
      50% {
        transform: translate(-50%, -50%) scale(1.3);
        box-shadow: 
          0 0 45px rgba(0,255,240,0.8),
          0 0 60px rgba(0,255,240,0.6),
          inset 0 0 25px rgba(255,255,255,1);
      }
    }
  
    .orbiting-circle {
      width: 8px;
      height: 8px;
      position: absolute;
      left: 50%;  
      top: 50%;   
      transform-origin: 0 0; 
      border-radius: 50%;
      background: radial-gradient(
        circle at center,
        rgba(0,255,240,0.8),
        rgba(255,52,179,0.8)
      );
      opacity: 0.7;
      transition: all 0.4s ease;
      filter: blur(1px);
      box-shadow: 0 0 15px currentColor;
    }
  
    .controls {
      width: 100%;
      display: grid;
      grid-template-columns: 1fr;
      gap: 15px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 15px;
    }
  
    label {
      color: var(--tertiary-color);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-family: 'Orbitron', sans-serif;
    }
  
    select, input[type="number"], #bpm {
      color: var(--primary-color);
      background: var(--select-bg);
      border: 1px solid rgba(0, 255, 240, 0.3);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      transition: all 0.3s ease;
    }
  
    select:hover, input[type="number"]:hover {
      border-color: var(--secondary-color);
    }
  
    .slider-container {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin: 0;
      min-width: 200px;
    }
  
    .slider-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
  
    .notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 15px 25px;
      border-radius: 8px;
      color: white;
      font-weight: 500;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.3s ease;
    }
  
    .notification.show {
      opacity: 1;
      transform: translateY(0);
    }
  
    .notification.success {
      background-color: var(--success-color);
      color: var(--bg-color);
    }
  
    .notification.error {
      background-color: var(--error-color);
      color: var(--bg-color);
    }
  
    .bar-multiplier {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-left: 15px;
    }
  
    .bar-multiplier label {
      font-size: 14px;
      font-family: 'Orbitron', sans-serif;
      color: var(--tertiary-color);
    }
  
    .bar-multiplier select {
      width: 50px;
      color: var(--primary-color);
      background: var(--select-bg);
      border: 1px solid rgba(0, 255, 240, 0.3);
      padding: 4px;
      font-size: 16px;
      border-radius: 4px;
      font-family: 'Orbitron', sans-serif;
      transition: all 0.3s ease;
    }
  
    .bar-multiplier select:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 10px rgba(0, 255, 240, 0.2);
    }
  
    @media (max-width: 1024px) {
      .container {
        gap: 1.5rem;
        padding: 0.75rem;
      }
      
      .sequencer {
        flex: 0 1 280px;
      }
    }
  
    @media (max-width: 768px) {
      .header {
        flex-direction: column;
        gap: 20px;
      }
      
      .slider-container {
        width: 100%;
      }
      
      .sequencer {
        width: 100%;
        max-width: 320px;
      }
    }
  
    @media (max-width: 480px) {
      .container {
        width: 98%;
        padding: 8px;
        margin: 5px auto;
      }
      
      .circle-container {
        width: min(140px, 45vw);
        height: min(140px, 45vw);
      }
    }
  </style>
  </head>
  <body>
  <div class="container">
    <div class="header">
      <div class="header-left">
        <h1>3 Beat Problem</h1>
        <div class="bpm-control">
          <label for="bpm">BPM:</label>
          <input type="text" id="bpm" 
                 inputmode="numeric" 
                 pattern="[0-9]*" 
                 min="60" 
                 max="300" 
                 value="120">
          <div class="bar-multiplier">
            <label for="barMultiplier">Bars:</label>
            <select id="barMultiplier">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
            </select>
          </div>
          <button id="playPause" disabled>
            <span class="play-icon show">▶</span>
            <span class="pause-icon">⏸</span>
          </button>
          <button id="exportMidi" class="export-button">Export MIDI</button>
        </div>
      </div>
      
      <div class="slider-container">
        <div class="slider-group">
          <label for="velocityRandomization">Velocity Randomization:</label>
          <input type="range" id="velocityRandomization" min="0" max="100" value="0" step="1">
          <span id="velocityRandomizationValue" class="value-display">0%</span>
        </div>
        <div class="slider-group">
          <label for="noteDuration">Note Duration:</label>
          <input type="range" id="noteDuration" min="0" max="100" value="50" step="1">
          <span id="noteDurationValue" class="value-display">50%</span>
        </div>
      </div>
    </div>
  
    <div class="sequencer" id="sequencer1">
      <div class="circle-container">
        <div class="circle">
          <div class="circle-inner-ring"></div>
          <div class="circle-middle-ring"></div>
          <div class="circle-outer-ring"></div>
          <canvas id="spectrogram1" class="spectrogram" width="180" height="180"></canvas>
        </div>
      </div>
      <div class="controls">
        <div class="control-group">
          <label for="sound1">Sound:</label>
          <select id="sound1"></select>
        </div>
        <div class="control-group">
          <label for="note1">Note:</label>
          <select id="note1"></select>
        </div>
        <div class="control-group">
          <label for="divisions1">Divisions:</label>
          <input type="number" id="divisions1" min="1" max="16" value="4" step="1">
        </div>
        <div class="volume-control">
          <label for="volume1">Volume:</label>
          <input type="range" id="volume1" min="0" max="100" value="70" step="1">
        </div>
      </div>
    </div>
  
    <div class="sequencer" id="sequencer2">
      <div class="circle-container">
        <div class="circle">
          <div class="circle-inner-ring"></div>
          <div class="circle-middle-ring"></div>
          <div class="circle-outer-ring"></div>
          <canvas id="spectrogram2" class="spectrogram" width="180" height="180"></canvas>
        </div>
      </div>
      <div class="controls">
        <div class="control-group">
          <label for="sound2">Sound:</label>
          <select id="sound2"></select>
        </div>
        <div class="control-group">
          <label for="note2">Note:</label>
          <select id="note2"></select>
        </div>
        <div class="control-group">
          <label for="divisions2">Divisions:</label>
          <input type="number" id="divisions2" min="1" max="16" value="3" step="1">
        </div>
        <div class="volume-control">
          <label for="volume2">Volume:</label>
          <input type="range" id="volume2" min="0" max="100" value="70" step="1">
        </div>
      </div>
    </div>
  
    <div class="sequencer" id="sequencer3">
      <div class="circle-container">
        <div class="circle">
          <div class="circle-inner-ring"></div>
          <div class="circle-middle-ring"></div>
          <div class="circle-outer-ring"></div>
          <canvas id="spectrogram3" class="spectrogram" width="180" height="180"></canvas>
        </div>
      </div>
      <div class="controls">
        <div class="control-group">
          <label for="sound3">Sound:</label>
          <select id="sound3"></select>
        </div>
        <div class="control-group">
          <label for="note3">Note:</label>
          <select id="note3"></select>
        </div>
        <div class="control-group">
          <label for="divisions3">Divisions:</label>
          <input type="number" id="divisions3" min="1" max="16" value="5" step="1">
        </div>
        <div class="volume-control">
          <label for="volume3">Volume:</label>
          <input type="range" id="volume3" min="0" max="100" value="70" step="1">
        </div>
      </div>
    </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
  <script>
  // Constants
  const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const OCTAVES = [3, 4, 5];
  const SOUNDS = ['sine', 'triangle', 'sawtooth', 'square', 'white', 'pink', 'brown', 'violet', 'blue'];
  const COLOR_NOISES = ['white', 'pink', 'brown', 'violet', 'blue'];
  
  const MIDI_NOTE_MAP = {
    'C': 60, 'C#': 61, 'D': 62, 'D#': 63, 'E': 64, 'F': 65,
    'F#': 66, 'G': 67, 'G#': 68, 'A': 69, 'A#': 70, 'B': 71
  };
  
  let savedNotes = ['C3', 'E4', 'G5']; // Store initial default notes
  let bpmInputTimeout;
  let lastValidBpm = 120;
  let barMultiplier = 1; // Initialize bar multiplier
  
  function noteToMidiNumber(note) {
    if (!note) return 60; // Default to middle C if note is undefined
    const noteName = note.slice(0, -1); // Remove octave
    const octave = parseInt(note.slice(-1));
    const baseNote = MIDI_NOTE_MAP[noteName];
    if (baseNote === undefined) return 60; // Default to middle C if note name is invalid
    return baseNote + ((octave - 4) * 12); // Adjust for octave
  }
  
  function createMidiFile() {
    try {
      const bpm = Math.max(parseInt(document.getElementById('bpm').value), 1);
      const barMultiplierValue = Math.max(parseInt(document.getElementById('barMultiplier').value), 1);
      
      const ticksPerBeat = 480;
      
      let midiData = {
        format: 0,
        numTracks: 1, 
        ticksPerBeat: ticksPerBeat,
        tracks: [[
          // Add tempo meta event
          {
            deltaTime: 0,
            meta: true,
            type: 'setTempo',
            microsecondsPerBeat: Math.floor(60000000 / bpm)
          }
        ]]
      };
  
      sequencers.forEach((seq, index) => {
        const channel = index;
        const ticksPerDivision = Math.floor(ticksPerBeat * 4 / seq.divisions);
        
        // Calculate total pattern length accounting for bar multiplier
        const totalSteps = seq.divisions * barMultiplierValue;
        
        for (let step = 0; step < totalSteps; step++) {
          const noteStep = step % seq.divisions;
          if (seq.pattern[noteStep]) {
            const noteNumber = seq.sound === 'noise' ? 60 : noteToMidiNumber(seq.note);
            const velocity = Math.floor(getRandomVelocity() * 127);
            const stepTime = step * ticksPerDivision;
            const noteDuration = Math.max(Math.floor(ticksPerDivision * getNoteDuration()), 1);
            
            // Note On event
            midiData.tracks[0].push({
              deltaTime: stepTime,
              channel: channel,
              type: 'noteOn',
              noteNumber: noteNumber,
              velocity: velocity
            });
            
            // Note Off event
            midiData.tracks[0].push({
              deltaTime: stepTime + noteDuration,
              channel: channel,
              type: 'noteOff', 
              noteNumber: noteNumber,
              velocity: 0
            });
          }
        }
      });
  
      // Sort events by time
      midiData.tracks[0].sort((a, b) => a.deltaTime - b.deltaTime);
      
      // Convert absolute times to delta times
      let lastTime = 0;
      midiData.tracks[0].forEach(event => {
        const absoluteTime = event.deltaTime;
        event.deltaTime = Math.max(0, absoluteTime - lastTime);
        lastTime = absoluteTime;
      });
  
      // Add end of track
      midiData.tracks[0].push({
        deltaTime: 0,
        meta: true,
        type: 'endOfTrack'
      });
  
      return midiData;
    } catch (error) {
      console.error('Error creating MIDI:', error);
      throw error;
    }
  }
  
  // Update generateMidiBlob function to properly encode MIDI data
  function generateMidiBlob(midiData) {
    try {
      const buffer = new ArrayBuffer(1024);
      const view = new DataView(buffer);
      let offset = 0;
  
      // Write header chunk
      const writeString = (str) => {
        for (let i = 0; i < str.length; i++) {
          view.setUint8(offset + i, str.charCodeAt(i));
        }
        offset += str.length;
      };
  
      const writeInt16 = (value) => {
        view.setInt16(offset, value, false);
        offset += 2;
      };
  
      const writeInt32 = (value) => {
        view.setInt32(offset, value, false);
        offset += 4;
      };
  
      const writeVarLength = (value) => {
        let v = value;
        if (v < 0) v = 0;
        
        if (v > 0x0FFFFFFF) v = 0x0FFFFFFF;
        
        let bytes = [];
        do {
          bytes.push(v & 0x7F);
          v = v >> 7;
        } while (v > 0);
        
        for (let i = bytes.length - 1; i >= 0; i--) {
          let b = bytes[i];
          if (i > 0) b |= 0x80;
          view.setUint8(offset, b);
          offset++;
        }
      };
  
      // Write header
      writeString('MThd');
      writeInt32(6); // Header length
      writeInt16(midiData.format);
      writeInt16(midiData.numTracks);
      writeInt16(midiData.ticksPerBeat);
  
      // Write track
      writeString('MTrk');
      const trackLengthOffset = offset;
      offset += 4; // Skip length for now
  
      // Write track events
      midiData.tracks[0].forEach(event => {
        writeVarLength(event.deltaTime);
        
        if (event.meta) {
          view.setUint8(offset++, 0xFF);
          
          if (event.type === 'setTempo') {
            view.setUint8(offset++, 0x51);
            view.setUint8(offset++, 0x03);
            view.setUint8(offset++, (event.microsecondsPerBeat >> 16) & 0xFF);
            view.setUint8(offset++, (event.microsecondsPerBeat >> 8) & 0xFF);
            view.setUint8(offset++, event.microsecondsPerBeat & 0xFF);
          } else if (event.type === 'endOfTrack') {
            view.setUint8(offset++, 0x2F);
            view.setUint8(offset++, 0x00);
          }
        } else {
          // Note events
          const statusByte = event.type === 'noteOn' ? 0x90 : 0x80;
          view.setUint8(offset++, statusByte | event.channel);
          view.setUint8(offset++, event.noteNumber & 0x7F);
          view.setUint8(offset++, event.velocity & 0x7F);
        }
      });
  
      // Write track length
      const trackLength = offset - trackLengthOffset - 4;
      view.setInt32(trackLengthOffset, trackLength, false);
  
      return new Blob([new Uint8Array(buffer.slice(0, offset))], {type: 'audio/midi'});
    } catch (error) {
      console.error('Error generating MIDI blob:', error);
      throw error;
    }
  }
  
  // Add export button click handler
  document.getElementById('exportMidi').addEventListener('click', function() {
    try {
      const midiData = createMidiFile();
      const blob = generateMidiBlob(midiData);
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = '3beat-pattern.mid';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showNotification('MIDI file exported successfully', 'success');
    } catch (error) {
      console.error('Error exporting MIDI:', error);
      showNotification('Failed to export MIDI file', 'error');
    }
  });
  
  // Add notification function
  function showNotification(message, type) {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    // Show notification
    setTimeout(() => notification.classList.add('show'), 100);
    
    // Remove notification
    setTimeout(() => {
      notification.classList.remove('show');
      setTimeout(() => notification.remove(), 300);
    }, 3000);
  }
  
  // Add event listener for the bar multiplier changes
  document.getElementById('barMultiplier').addEventListener('change', function() {
    barMultiplier = parseInt(this.value);
    updatePlayingSequencer();
  });
  
  // Add event listener for the export button
  document.getElementById('exportMidi').addEventListener('click', function() {
    try {
      const midiData = createMidiFile();
      const blob = generateMidiBlob(midiData);
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = '3beat-pattern.mid';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      // Show success notification
      showNotification('MIDI file exported successfully', 'success');
    } catch (error) {
      console.error('Error exporting MIDI:', error);
      showNotification('Failed to export MIDI file', 'error');
    }
  });
  
  // Add notification styles to CSS
  
  // State
  let isPlaying = false;
  let sequencers = [];
  let sequences = [];
  
  // Audio setup
  const analyzerNodes = Array(3).fill().map(() => new Tone.Analyser('fft', 512));
  const gainNodes = Array(3).fill().map(() => new Tone.Gain().toDestination());
  gainNodes.forEach(node => node.gain.value = 0.7); // Set initial volume to 70%
  
  // Connect analyzer nodes to their respective gain nodes
  analyzerNodes.forEach((analyzer, index) => gainNodes[index].connect(analyzer));
  
  // Updated visualization function
  function visualize() {
      if (!isPlaying) return;
      
      requestAnimationFrame(visualize);
    
      analyzerNodes.forEach((analyzer, index) => {
        const spectrogramCanvas = document.getElementById(`spectrogram${index + 1}`);
        if (!spectrogramCanvas) return;
        
        const spectrogramCtx = spectrogramCanvas.getContext('2d');
        const bufferLength = analyzer.size;
        const dataArray = analyzer.getValue();
    
        // Clear the canvas first
        spectrogramCtx.clearRect(0, 0, spectrogramCanvas.width, spectrogramCanvas.height);
    
        // Create circular clip path
        spectrogramCtx.save();
        spectrogramCtx.beginPath();
        spectrogramCtx.arc(
          spectrogramCanvas.width / 2,
          spectrogramCanvas.height / 2,
          Math.min(spectrogramCanvas.width, spectrogramCanvas.height) / 2 - 10,
          0,
          Math.PI * 2
        );
        spectrogramCtx.clip();
    
        // Draw almost invisible background
        spectrogramCtx.fillStyle = 'rgba(0, 255, 255, 0.02)';
        spectrogramCtx.fillRect(0, 0, spectrogramCanvas.width, spectrogramCanvas.height);
    
        const barWidth = (spectrogramCanvas.width / bufferLength) * 2.5;
        let x = 0;
    
        for (let i = 0; i < bufferLength; i++) {
          // Start with a very low baseline
          let value = dataArray[i];
          
          // Check if value is finite and non-null
          if (!Number.isFinite(value) || value === null) {
            value = -140; // Use minimum value instead of 0
          }
          
          // Ensure the value is properly scaled
          value = Math.max(-140, Math.min(0, value));
          
          // Scale the height more conservatively
          const barHeight = ((value + 140) / 140) * spectrogramCanvas.height * 0.8;
    
          if (barHeight > 0) {
            try {
              const gradient = spectrogramCtx.createLinearGradient(
                0,
                spectrogramCanvas.height,
                0,
                Math.max(0, spectrogramCanvas.height - barHeight)
              );
              
              // Use more subtle gradient with lower opacity
              gradient.addColorStop(0, `rgba(0, 255, 255, 0.1)`);
              gradient.addColorStop(1, `rgba(0, 255, 255, 0.4)`);
    
              spectrogramCtx.fillStyle = gradient;
              spectrogramCtx.fillRect(
                x,
                spectrogramCanvas.height - barHeight,
                barWidth,
                barHeight
              );
            } catch (error) {
              console.warn('Visualization error:', error);
              spectrogramCtx.fillStyle = 'rgba(0, 255, 255, 0.2)';
              spectrogramCtx.fillRect(
                x,
                spectrogramCanvas.height - barHeight,
                barWidth,
                barHeight
              );
            }
          }
    
          x += barWidth + 1;
        }
        
        spectrogramCtx.restore();
      });
  }
  
  // Update the DOMContentLoaded event listener to include spectrogram initialization
  document.addEventListener('DOMContentLoaded', () => {
      // Clear and initialize spectrograms
      document.querySelectorAll('.spectrogram').forEach(canvas => {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Create circular clip path
        ctx.save();
        ctx.beginPath();
        ctx.arc(
          canvas.width / 2,
          canvas.height / 2,
          Math.min(canvas.width, canvas.height) / 2 - 10,
          0,
          Math.PI * 2
        );
        ctx.clip();
        
        ctx.restore();
      });
      
      // Initialize other components
      populateNoteAndSoundSelects();
      updateSequencer();
      initializeBpmInput();
  });
  
  // Utility functions
  const getRandomVelocity = () => {
    const randomization = parseInt(document.getElementById('velocityRandomization').value);
    return 0.7 + (Math.random() * 2 - 1) * (randomization / 100) * 0.7;
  };
  
  const getNoteDuration = () => {
    const displayValue = parseInt(document.getElementById('noteDuration').value);
    // Scale 0-100 to 1-400 
    const actualValue = 1 + (displayValue * 399/100);
    return actualValue / 400;
  };
  
  const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
  
  // UI Setup
  function populateNoteAndSoundSelects() {
    const noteSelects = ['note1', 'note2', 'note3'].map(id => document.getElementById(id));
    const soundSelects = ['sound1', 'sound2', 'sound3'].map(id => document.getElementById(id));
  
    const musicalSequence = OCTAVES.flatMap(octave => NOTES.map(note => `${note}${octave}`));
  
    noteSelects.forEach((select, index) => {
      select.innerHTML = musicalSequence.map(note => `<option value="${note}">${note}</option>`).join('');
      select.value = ['C3', 'E4', 'G5'][index];
    });
  
    soundSelects.forEach((select, index) => {
      select.innerHTML = SOUNDS.map(sound => `<option value="${sound}">${sound.charAt(0).toUpperCase() + sound.slice(1)}</option>`).join('');
      select.value = 'sine';
      
      select.addEventListener('change', (event) => {
        const noteSelect = document.getElementById(`note${index + 1}`);
        const isNoise = COLOR_NOISES.includes(event.target.value);
        
        if (isNoise) {
          // Save current note before disabling
          savedNotes[index] = noteSelect.value;
          noteSelect.disabled = true;
          noteSelect.value = SOUND_TO_NOTE[event.target.value];
        } else {
          // Restore saved note when switching back to non-noise sound
          noteSelect.disabled = false;
          noteSelect.value = savedNotes[index];
        }
      });
    });
  }
  
  function resetDotColors() {
    document.querySelectorAll('.dot').forEach(dot => {
      dot.style.backgroundColor = dot.classList.contains('active') ? 
        'var(--primary-color)' : 
        'var(--secondary-color)';
      dot.style.boxShadow = 'none';
    });
  }
  
  function createDots(sequencerId, divisions) {
    const circle = document.querySelector(`#${sequencerId} .circle`);
    if (!circle) {
      console.error(`Circle element not found for sequencer ${sequencerId}`);
      return;
    }
  
    // Clear existing content
    circle.innerHTML = '';
    
    // Add base elements in correct order
    const baseElements = `
      <div class="circle-inner-ring"></div>
      <div class="circle-middle-ring"></div>
      <div class="circle-outer-ring"></div>
      <canvas id="spectrogram${sequencerId.slice(-1)}" class="spectrogram" width="180" height="180"></canvas>
    `;
    circle.innerHTML = baseElements;
    
    // Create and append dots
    for (let i = 0; i < divisions; i++) {
      const angle = (i / divisions) * 2 * Math.PI - Math.PI / 2;
      const radius = 40;
      const dot = document.createElement('div');
      dot.className = 'dot';
      dot.dataset.index = i;
      dot.style.left = `${50 + radius * Math.cos(angle)}%`;
      dot.style.top = `${50 + radius * Math.sin(angle)}%`;
      
      // Add event listener directly to the dot element
      dot.addEventListener('click', () => {
        try {
          toggleDot(sequencerId, i);
          if (!isPlaying) {
            resetDotColors();
          }
        } catch (error) {
          console.error('Error toggling dot:', error);
        }
      });
      
      circle.appendChild(dot);
    }
  
    // Add orbiting circles after dots
    addOrbitingCircles(circle);
  }
  
  function addOrbitingCircles(circle) {
    const orbitingCircleSizes = ['small', 'medium', 'large'];
    const radiusFactors = [1.2, 1.5, 1.8]; 
    const speedFactors = [8, 12, 15]; 
    const baseRadius = 40;
  
    orbitingCircleSizes.forEach((size, index) => {
      const orbitingCircle = document.createElement('div');
      orbitingCircle.className = `orbiting-circle orbiting-circle-${size}`;
      
      const startAngle = Math.random() * Math.PI * 2;
      const orbitRadius = baseRadius * radiusFactors[index];
      
      // Update the animation to use translate(-50%, -50%) to center the circle
      const keyframes = `
        @keyframes orbit${index + 1} {
          from {
            transform: translate(-50%, -50%) rotate(${startAngle}rad) translateX(${orbitRadius}px) rotate(-${startAngle}rad);
          }
          to {
            transform: translate(-50%, -50%) rotate(${startAngle + 2 * Math.PI}rad) translateX(${orbitRadius}px) rotate(-${startAngle + 2 * Math.PI}rad);
          }
        }
      `;
  
      orbitingCircle.style.cssText = `
        width: ${8 - index}px;
        height: ${8 - index}px;
        animation: orbit${index + 1} ${speedFactors[index]}s linear infinite;
      `;
  
      // Remove any existing style with the same animation name
      const existingStyle = document.querySelector(`style[data-orbit="${index + 1}"]`);
      if (existingStyle) {
        existingStyle.remove();
      }
  
      // Add the new keyframes
      const styleSheet = document.createElement('style');
      styleSheet.setAttribute('data-orbit', index + 1);
      styleSheet.textContent = keyframes;
      document.head.appendChild(styleSheet);
  
      circle.appendChild(orbitingCircle);
    });
  }
  
  // Update the toggleDot function with error handling
  function toggleDot(sequencerId, index) {
    try {
      const sequencerIndex = parseInt(sequencerId.slice(-1)) - 1;
      const dot = document.querySelector(`#${sequencerId} .dot[data-index="${index}"]`);
      
      if (!dot) {
        console.error(`Dot element not found for sequencer ${sequencerId}, index ${index}`);
        return;
      }
      
      if (!sequencers[sequencerIndex]) {
        console.error(`Sequencer not found at index ${sequencerIndex}`);
        return;
      }
      
      dot.classList.toggle('active');
      sequencers[sequencerIndex].pattern[index] = dot.classList.contains('active');
      
      if (isPlaying) {
        updatePlayingSequencer();
      }
    } catch (error) {
      console.error('Error in toggleDot:', error);
    }
  }
  
  function updateSequencer() {
    const bpm = parseInt(document.getElementById('bpm').value);
    const notes = ['note1', 'note2', 'note3'].map(id => document.getElementById(id).value);
    const sounds = ['sound1', 'sound2', 'sound3'].map(id => document.getElementById(id).value);
    const divisions = ['divisions1', 'divisions2', 'divisions3'].map(id => parseInt(document.getElementById(id).value));
  
    // Store the old patterns if they exist
    const oldPatterns = sequencers.map(seq => seq ? [...seq.pattern] : []);
    const oldDivisions = sequencers.map(seq => seq ? seq.divisions : 0);
  
    sequencers = divisions.map((div, index) => {
      // Get the old pattern for this sequencer
      const oldPattern = oldPatterns[index] || [];
      const oldDiv = oldDivisions[index];
      
      // Create a new pattern that preserves existing dots
      let newPattern;
      if (div > oldDiv) {
        // If new divisions is larger, extend the pattern with false values
        newPattern = [...oldPattern, ...new Array(div - oldDiv).fill(false)];
      } else if (div < oldDiv) {
        // If new divisions is smaller, truncate the pattern
        newPattern = oldPattern.slice(0, div);
      } else {
        // If same number of divisions, keep existing pattern
        newPattern = oldPattern;
      }
  
      return {
        note: COLOR_NOISES.includes(sounds[index]) ? 
          SOUND_TO_NOTE[sounds[index]] : 
          (notes[index] || savedNotes[index]), // Use saved note as fallback
        sound: sounds[index],
        divisions: div,
        pattern: newPattern.length ? newPattern : new Array(div).fill(false)
      };
    });
  
    // Update UI for each sequencer
    sequencers.forEach((seq, i) => {
      createDots(`sequencer${i + 1}`, seq.divisions);
      
      // Restore active state for dots
      seq.pattern.forEach((active, dotIndex) => {
        if (active) {
          const dot = document.querySelector(`#sequencer${i + 1} .dot[data-index="${dotIndex}"]`);
          if (dot) {
            dot.classList.add('active');
          }
        }
      });
    });
  
    if (isPlaying) {
      updatePlayingSequencer();
    }
  }
  
  // Update playing sequencer with adjusted timing
  function updatePlayingSequencer() {
    stopSequencer();
    startSequencer();
  }
  
  // Adjusted startSequencer function to handle adjusted timing
  function startSequencer() {
    try {
      const bpm = parseInt(document.getElementById('bpm').value);
      // Ensure positive BPM value
      const adjustedBpm = Math.max(bpm / (1 + (barMultiplier - 1) * 0.5), 1);
      
      // Stop any existing transport
      Tone.Transport.stop();
      Tone.Transport.cancel();
      
      // Set new BPM
      Tone.Transport.bpm.value = adjustedBpm;
      
      // Create sequences
      sequences = sequencers.map((seq, index) => {
        const stepTime = Math.max(60 / (adjustedBpm * seq.divisions), 0.01);
        const sequence = createSequence(seq, index, stepTime);
        return sequence;
      }).filter(seq => seq !== null); // Filter out any failed sequences
  
      // Start transport with a small delay to ensure proper initialization
      Tone.Transport.start('+0.1');
      visualize();
    } catch (error) {
      console.error('Error starting sequencer:', error);
      stopSequencer();
    }
  }
  
  function createSequence(seq, index, stepTime) {
    try {
      // Initialize synth/noise sources once and reuse them
      let source;
      if (COLOR_NOISES.includes(seq.sound)) {
        if (seq.sound === 'violet') {
          source = new Tone.Noise('white');
          const highPass1 = new Tone.Filter({
            type: 'highpass',
            frequency: 500,
            rolloff: -12
          });
          const highPass2 = new Tone.Filter({
            type: 'highpass',
            frequency: 1000,
            rolloff: -12
          });
          const highShelf = new Tone.Filter({
            type: 'highshelf',
            frequency: 2000,
            gain: 6
          });
          source.chain(highPass1, highPass2, highShelf, gainNodes[index]);
        } else if (seq.sound === 'blue') {
          source = new Tone.Noise('white');
          const blueFilter = new Tone.Filter({
            type: 'highpass',
            frequency: 500,
            rolloff: -12
          });
          source.chain(blueFilter, gainNodes[index]);
        } else {
          source = new Tone.Noise(seq.sound).connect(gainNodes[index]);
        }
      } else {
        source = new Tone.Synth({
          oscillator: { type: seq.sound }
        }).connect(gainNodes[index]);
      }
  
      // Create an extended pattern array that repeats based on bar multiplier
      const extendedPattern = Array(seq.divisions * barMultiplier)
        .fill(0)
        .map((_, i) => seq.pattern[i % seq.divisions]);
  
      // Ensure positive stepTime
      const adjustedStepTime = Math.max(stepTime * (1 + (barMultiplier - 1) * 0.5), 0.01);
  
      return new Tone.Sequence((time, step) => {
        // Ensure time is non-negative
        if (time < 0) return;
        
        // Calculate the visual step (which dot to highlight)
        const visualStep = step % seq.divisions;
        updateDotColors(index, visualStep);
        
        if (extendedPattern[step]) {
          const velocity = getRandomVelocity();
          const duration = Math.max(getNoteDuration() * adjustedStepTime, 0.01);
          
          try {
            if (COLOR_NOISES.includes(seq.sound)) {
              source.start(Math.max(time, 0)).stop(Math.max(time + duration, 0.01));
            } else {
              source.triggerAttackRelease(seq.note, duration, Math.max(time, 0), velocity);
            }
          } catch (error) {
            console.warn('Error playing sound:', error);
          }
        }
      }, [...Array(seq.divisions * barMultiplier).keys()], adjustedStepTime).start(0);
    } catch (error) {
      console.error('Error in createSequence:', error);
      return null;
    }
  }
  
  // Update the stopSequencer function to properly clean up
  function stopSequencer() {
    try {
      Tone.Transport.stop();
      Tone.Transport.cancel();
      
      sequences.forEach(seq => {
        if (seq && seq.dispose) {
          seq.dispose();
        }
      });
      sequences = [];
      resetDotColors();
      
      // Clear spectrograms
      document.querySelectorAll('.spectrogram').forEach(canvas => {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      });
    } catch (error) {
      console.error('Error stopping sequencer:', error);
    }
  }
  
  // Add function to update dot colors
  function updateDotColors(sequencerIndex, currentStep) {
    const dots = document.querySelectorAll(`#sequencer${sequencerIndex + 1} .dot`);
    dots.forEach((dot, index) => {
      if (index === currentStep) {
        dot.style.backgroundColor = dot.classList.contains('active') ? 
          'var(--primary-color)' : 
          'var(--secondary-color)';
        dot.style.boxShadow = '0 0 15px var(--primary-color)';
      } else {
        dot.style.backgroundColor = dot.classList.contains('active') ? 
          'var(--primary-color)' : 
          'var(--secondary-color)';
        dot.style.boxShadow = 'none';
      }
    });
  }
  
  // Fix play/pause functionality
  function playPauseAction() {
    isPlaying = !isPlaying;
    
    if (isPlaying) {
      document.querySelector('.play-icon').classList.remove('show');
      document.querySelector('.pause-icon').classList.add('show');
      startSequencer();
    } else {
      document.querySelector('.play-icon').classList.add('show');
      document.querySelector('.pause-icon').classList.remove('show');
      stopSequencer();
    }
  }
  
  // Add initialization code at the end of the script
  document.addEventListener('DOMContentLoaded', () => {
    // Clear and initialize spectrograms
    document.querySelectorAll('.spectrogram').forEach(canvas => {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Create circular clip path
      ctx.save();
      ctx.beginPath();
      ctx.arc(
        canvas.width / 2,
        canvas.height / 2,
        Math.min(canvas.width, canvas.height) / 2 - 10,
        0,
        Math.PI * 2
      );
      ctx.clip();
      
      ctx.restore();
    });
    
    // Enable play button initially if BPM is valid
    const bpmInput = document.getElementById('bpm');
    const playButton = document.getElementById('playPause');
    const bpmValue = parseInt(bpmInput.value);
    playButton.disabled = bpmValue < 60 || bpmValue > 300;
    
    populateNoteAndSoundSelects();
    updateSequencer();
    initializeBpmInput();
    
    // Initialize Tone.js
    Tone.start();
  });
  
  // Event listeners
  document.getElementById('playPause').addEventListener('click', playPauseAction);
  
  document.getElementById('bpm').addEventListener('input', () => {
    const bpm = parseInt(document.getElementById('bpm').value);
    Tone.Transport.bpm.value = bpm;
    if (isPlaying) {
      stopSequencer();
      startSequencer();
    }
  });
  
  ['note1', 'note2', 'note3', 'sound1', 'sound2', 'sound3', 'divisions1', 'divisions2', 'divisions3'].forEach(id => {
    document.getElementById(id).addEventListener('change', updateSequencer);
  });
  
  document.querySelectorAll('[id^="volume"]').forEach((slider, index) => {
    slider.addEventListener('input', function() {
      gainNodes[index].gain.value = this.value / 100;
    });
  });
  
  document.getElementById('velocityRandomization').addEventListener('input', function() {
    document.getElementById('velocityRandomizationValue').textContent = this.value + '%';
  });
  
  document.getElementById('noteDuration').addEventListener('input', function() {
    document.getElementById('noteDurationValue').textContent = this.value + '%';
  });
  
  function initializeBpmInput() {
    const bpmInput = document.getElementById('bpm');
    const playButton = document.getElementById('playPause');
    
    // Set initial value with padding
    bpmInput.value = lastValidBpm.toString().padStart(3, '0');
    
    bpmInput.addEventListener('input', function(e) {
      clearTimeout(bpmInputTimeout);
      
      let value = e.target.value.replace(/\D/g, '');
      let cursorPosition = this.selectionStart;
      
      // Handle single digit input
      if (value.length === 1) {
        if (cursorPosition === 1) {
          // Replace first digit
          value = value.padStart(3, '0');
        } else if (cursorPosition === 2) {
          // Replace second digit
          value = lastValidBpm.toString().padStart(3, '0').slice(0, 1) + 
                 value + 
                 lastValidBpm.toString().padStart(3, '0').slice(2);
        } else if (cursorPosition === 3) {
          // Replace third digit
          value = lastValidBpm.toString().padStart(3, '0').slice(0, 2) + value;
        }
      }
      
      // Ensure 3 digits
      value = value.slice(0, 3).padStart(3, '0');
      
      // Cap first digit at 3
      if (parseInt(value[0]) > 3) {
        value = '300';
      }
      
      let numValue = parseInt(value);
      
      // Validate range
      if (numValue < 60) {
        numValue = 60;
        value = '060';
      } else if (numValue > 300) {
        numValue = 300;
        value = '300';
      }
      
      // Update input value
      this.value = value;
      
      // Restore cursor position
      this.setSelectionRange(cursorPosition, cursorPosition);
      
      // Toggle invalid class
      this.classList.toggle('invalid', numValue < 60 || numValue > 300);
      
      // Enable/disable play button
      playButton.disabled = numValue < 60 || numValue > 300;
      
      // Update lastValidBpm after short delay
      bpmInputTimeout = setTimeout(() => {
        lastValidBpm = numValue;
        this.classList.remove('invalid');
        
        // Update transport if playing
        if (isPlaying) {
          Tone.Transport.bpm.value = numValue;
        }
      }, 300);
    });
    
    // Handle focus
    bpmInput.addEventListener('focus', function() {
      // Store current cursor position
      const cursorPosition = this.selectionStart;
      // Ensure 3 digits are shown
      this.value = parseInt(this.value).toString().padStart(3, '0');
      // Restore cursor position
      this.setSelectionRange(cursorPosition, cursorPosition);
    });
    
    // Handle blur
    bpmInput.addEventListener('blur', function() {
      let value = parseInt(this.value);
      if (value < 60) value = 60;
      if (value > 300) value = 300;
      this.value = value.toString().padStart(3, '0');
      lastValidBpm = value;
      this.classList.remove('invalid');
    });
  }
  
  // Modify the play button CSS to show disabled state
  document.querySelector('#playPause').style.cssText += `
    &:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
    }
  `;
  
  // Call initialization after DOM content loaded
  document.addEventListener('DOMContentLoaded', () => {
    initializeBpmInput();
  });
  
  </script>
  
  </body></html>